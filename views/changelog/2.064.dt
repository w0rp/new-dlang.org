extends base

append head
    title D Programming Language Version #{thisVersion} Change Log

append content
    header
        h1 Change Log &ndash; v#{thisVersion}

    |!= h2(toc, "language-ehancements", "Language Enhancements")

    |!= h3(toc, "package-modules", "Package Modules")

    p
        | The new package import feature allows you to define a library
        | module which has the purpose of publicly importing any other
        | modules in that library. The user can then simply import this
        | one module and use the library as if the user import all the
        | modules at once. For example:

    strong libweb/client.d:

    code
        pre
            | module libweb.client;
            |
            | void runClient() { }

    strong libweb/server.d:

    code
        pre
            | module libweb.server;
            |
            | void runServer() { }

    strong libweb/package.d:

    code
        pre
            | module libweb;
            |
            | public import libweb.client;
            | public import libweb.server;

    p
        | Notice that the package module must always have the file name
        | <strong>package.d</strong>. The module name is the qualified name
        | of the package. The user then uses the standard import syntax
        | to import a package module, simply using the module declaration
        | name to import the package:

    strong test.d:

    code
        pre
            | module test;
            |
            | import libweb;
            |
            | void main()
            | {
            |     startServer();
            |     startClient();
            | }

    p The following is an example of a package module of a sub-package:

    strong libweb/utils/package.d:

    code
        pre
            | // fully qualified name of the package, not just "utils"!
            | module libweb.utils;
            |
            | // publicly import modules from within 'libweb.utils'
            | public import libweb.utils.conv;
            | public import libweb.utils.text;

    p To import this subpackage, use the standard module import declaration:

    code
        pre
            | module test;
            |
            | import libweb.utils;
            |
            | void main()
            | {
            | }

    |!= h4(toc, "package-modules-rationale", "Rationale")

    p
        | Until now <em>public import</em> modules were implementable,
        | but only by convention. The user would typically have to import a
        | specific module specified by the library author, e.g.
        | <strong>libweb.all</strong> or <strong>libweb._</strong>.
        | Introducing the package import feature standardizes this common
        | convention of library authors

    |!= h3(toc, "eponymous-template-syntax", "Eponymous Template Syntax")

    p
        | The new eponymous template syntax allows you to write shorter
        | templates without having to explicitly define and repeat the
        | template name when using traditional eponymous templates.
        | For example, before 2.064 eponymous templates were written and
        | used like the following:

    code
        pre
            | template Tuple(T...) { alias Tuple = T; }
            |
            | template isIntOrFloat(T)
            | {
            |     static if (is(T == int) || is(T == float))
            |         enum isIntOrFloat = true;
            |     else
            |         enum isIntOrFloat = false;
            | }
            |
            | void main()
            | {
            |     alias Tup = Tuple!(int, float, string);
            |     // int is an int or a float
            |     static assert(isIntOrFloat!(Tup[0]));
            |     // float is an int or a float
            |     static assert(isIntOrFloat!(Tup[1]));
            |     // string is neither an int nor a float
            |     static assert(!isIntOrFloat!(Tup[2]));
            | }

    p
        | With the new eponymous syntax, the implementation code becomes
        | much simpler:

    code
        pre
            | alias Tuple(T...) = T;
            |
            | enum isIntOrFloat(T) = is(T == int) || is(T == float);
            |
            | void main()
            | {
            |     alias Tup = Tuple!(int, float, string);
            |     // int is an int or a float
            |     static assert(isIntOrFloat!(Tup[0]));
            |     // float is an int or a float
            |     static assert(isIntOrFloat!(Tup[1]));
            |     // string is neither an int nor a float
            |     static assert(!isIntOrFloat!(Tup[2]));
            | }

    p
        | Notice how you need to start the declaration of such a template
        | with an <strong>alias</strong> or <strong>enum</strong>,
        | rather than starting it with the keyword <strong>template</strong>.

    |!= h4(toc, "eponymous-template-syntax-limitations", "Limitations")

    p
        | Currently you cannot define template constraints for these types
        | of templates. This limitation may be lifted in a future release.

    |!= h3(toc, "postfix-after-new", "Postfix Expressions After 'new'")

    p
        | Before 2.064, you could not both instantiate a new class and call
        | a method or access a property of the object without having to wrap
        | the <strong>new</strong> expression in parentheses:

    code
        pre
            | class Server
            | {
            |     this(string[] args) { }
            |     void run() { }
            | }
            |
            | void main(string[] args)
            | {
            |     (new Server(args)).run();
            | }

    p
        | In 2.064 this limitation has been lifted,
        | allowing you to write the code as follows:

    code
        pre
            | class Server
            | {
            |     this(string[] args) { }
            |     void run() { }
            | }
            |
            | void main(string[] args)
            | {
            |     new Server(args).run();
            | }

    p
        | <strong>Note:</strong> When instantiating a class with the default
        | constructor, you must insert an empty set of parentheses before
        | accessing a field or calling a method on the object:

    code
        pre
            | class Server
            | {
            |     this() { }
            |     void run() { }
            | }
            |
            | void main()
            | {
            |     // error
            |     new Server.run();
            |     // ok
            |     new Server().run();
            | }

    |!= h3(toc, "ifti-enclosing-scope", "IFTI & Enclosing Scope")

    p
        | Implicit Function Template Instantiation now supports enclosing
        | type/scope deduction. This allows you to write code such as
        | the following:

    code
        pre
            | struct A
            | {
            |     struct Foo { }
            | }
            |
            | struct B
            | {
            |     struct Foo { }
            | }
            |
            | /**
            | Templated function which expects
            | the second argument to be of type 'Foo',
            | which is a nested in the type 'T'.
            | */
            | void call(T)(T t, T.Foo foo) { }
            |
            | void main()
            | {
            |     auto a = A();
            |     auto a_f = A.Foo();
            |     // ok
            |     call(a, a_f);
            |
            |     auto b = B();
            |     auto b_f = B.Foo();
            |     // ok
            |     call(b, b_f);
            |
            |     // fails: b_f is typed as B.Foo, not A.Foo
            |     call(a, b_f);
            | }

    p
        | This
        abbr(title="Implicit Template Function Instantiation") IFTI
        | feature also allows you to retrieve the module of a
        | symbol, by using an <strong>alias</strong> template parameter,
        | rather than a type one:

    code
        pre
            | module my_module;
            |
            | struct A
            | {
            |     struct B { }
            | }
            |
            | void foo(alias Mod)(Mod.A, Mod.A.B)
            | {
            |     // 'Mod' is deduced to be the module 'my_module'
            |     // which encloses the struct 'A'
            |     static assert(__traits(isSame, Mod, my_module));
            | }
            |
            | void main()
            | {
            |     A a;
            |     A.B b;
            |     // ok
            |     foo(a, b);
            | }

    |!= h3(toc, "ddoc-symbol-warning", "DDoc Symbol Mismatch Warning")

    p
        | DDoc can now warn the user when the symbol names in a ddoc comment
        | do not match the actual code. Here is an example documented
        | function, where the parameter names are wrongly documented.

    code
        pre
            | /**
            |     This is the sum function.
            |
            |     params:
            |         x = The first parameter
            |         y = The second parameter
            | */
            | int sum(int a, int b)
            | {
            |     return a + b;
            | }

    p
        | Generating the documentation with warnings enabled
        | will emit the following:

    code
        pre dmd -D -c -w test.d

    code
        pre
            | Warning: Ddoc: function declaration has no parameter 'x'
            | Warning: Ddoc: function declaration has no parameter 'y'

    p
        | This feature can help ensure that the documentation for library
        | code is always kept up-to-date.

    p
        | <strong>Note:</strong> Remember to use the <strong>-w</strong>
        | switch when building the documentation with the <strong>-D</strong>
        | switch in order to enable these warnings.

    |!= h3(toc, "string-literal-charp", "Slicing String Literals and char*")

    p
        | To help ease interacting with C libraries which expect strings as
        | null-terminated pointers, slicing string <strong>literals</strong>
        | (<em>not</em> variables!) will now allow the implicit
        | conversion to a <strong>char</strong> pointer:

    code
        pre
            | extern(C) void call(const(char)* str) { }
            |
            | void main()
            | {
            |     const(char)* abc = "abc";
            |     // already previously allowed
            |     call(abc);
            |
            |     const(char)* ab = "abc"[0 .. 2];
            |     // allowed in 2.064
            |     call(ab);
            | }

    |!= h3(toc, "templates-and-overloads", "Templates and Overloads")

    p
        | Templated and non-template functions can now be overloaded against
        | each other:

    code
        pre
            | auto foo(int n) { return 1; }
            | auto foo(T)(T t) { return 2; }
            |
            | void main()
            | {
            |     assert(foo(100) == 1);
            |     assert(foo("a") == 2);
            |
            |     // Integer literal 10L can be converted to int
            |     // without loss of precision.
            |     // Then the call matches to foo(int n).
            |     assert(foo(10L) == 1);
            |
            |     // A runtime variable 'num' typed long
            |     // is not implicitly convertible to int.
            |     // Then the call matches to foo(T)(T t).
            |     long num = 10L;
            |     assert(foo(num) == 2);
            | }

    |!= h3(toc, "cross-moduletemplate-overloads", "Cross-module Template Overloads")

    p
        | Template declarations are now overloadable just like regular
        | function declarations. Templates with matching names from
        | multiple modules will introduce an overload set:

    code
        pre
            | module a;
            |
            | template Traits(T) if (is(T == double))
            | {
            |     enum Traits = "abc";
            | }
            |
            | auto func(T, A...)(A args) if (is(T == double))
            | {
            |     return 1;
            | }

    code
        pre
            | module b;
            |
            | template Traits(T) if (is(T == string))
            | {
            |     enum Traits = "def";
            | }
            |
            | auto func(T, A...)(A args) if (is(T == string))
            | {
            |     return 2;
            | }

    code
        pre
            | module c;
            | import a, b;
            |
            | // matches to a.Traits
            | static assert(Traits!double == "abc");
            | // matches to b.Traits
            | static assert(Traits!string == "def");
            |
            | void main()
            | {
            |     // matches to a.func(T, A...)
            |     assert(func!double(1, "msg") == 1);
            |
            |     // matches to b.func(T, A...)
            |     assert(func!string(1, "msg") == 2);
            | }

    |!= h3(toc, "cross-moduletemplate-overload-limitations", "Limitations")

    p
        | Merging template overload sets by using an alias declaration
        | is currently not supported. The limitation will be lifted
        | in a future release.

    |!= h2(toc, "compiler-changes", "Compiler Changes")

    |!= h3(toc, "printing-dependencies", "Printing Dependencies")

    p
        | You can now use the <strong>-deps</strong> switch without having
        | to specify a filename. The dependencies will then be printed to
        | standard output, allowing both users and tools to introspect the
        | dependencies in the output.

    p The types of dependencies which are printed out are as follows:

    dl
        dt depsImport
        dd
            | Module imports found (same as -deps=file output,
            | except prefixed with depsImport)
        dt depsVersion
        dd Versions (except standard ones and ones set in the module itself)
        dt depsFile
        dd
            | String imports found, e.g.
            code string x = import("foo.txt");
        dt depsLib
        dd
            | Libraries specified with a
            code pragma(lib)
            | statement
        dt depsDebug
        dd
            | Any
            code debug()
            | statements found (except the ones set in the module itself)

    |!= h2(toc, "compiler-enchancements", "Compiler Enhancements")

    |!= h3(toc, "getunittests-trait", "'getUnitTests' Trait")

    p
        | A new trait, <strong>getUnitTests</strong>, has been introduced.
        | With the new <strong>getUnitTests</strong> trait you can
        | retrieve all unittest in a module or an aggregate, and then run the
        | tests manually. Here's an example of implementing a custom unittest
        | running routine which prints out some additional statistics:

    code
        pre
            | import core.runtime;
            | import core.exception;
            | import std.stdio;
            |
            | shared static this()
            | {
            |     // this overrides the default D runtime
            |     // unittest runner function, since we're providing
            |     // a __traits-based one in our main function.
            |     Runtime.moduleUnitTester = { return true; };
            | }
            |
            | unittest
            | {
            |     // passes.
            |     assert(1);
            | }
            |
            | unittest
            | {
            |     // fails.
            |     assert(0);
            | }
            |
            | unittest
            | {
            |     // passes.
            |     assert(1);
            | }
            |
            | void main()
            | {
            |     // collect all thrown exceptions.
            |     Throwable[] errors;
            |     // count the number of unittests which pass.
            |     size_t passCount;
            |
            |     // iterate over each unittest (this is a tuple).
            |     foreach (test; __traits(getUnitTests, my_module))
            |     {
            |         try
            |         {
            |             test();
            |             passCount++;
            |         }
            |         catch (Throwable error)
            |         {
            |             errors ~= error;
            |         }
            |     }
            |
            |     // print out the errors or the statistics.
            |     if (errors.length)
            |     {
            |         writeln("Some unittests failed:\n");
            |         foreach (error; errors)
            |             writeln(error);
            |     }
            |     else
            |     {
            |         writefln(
            |             "All unittests passed. Passed unittest count: %s",
            |             passCount
            |         );
            |     }
            | }

    p
        | <strong>Note:</strong> You must compile with the
        | <strong>-unittest</strong> flag to be able to retrieve the unittests.

    p
        | <strong>Note:</strong> By default the D runtime provides its
        | own unittest execution function. If you want to avoid it from being
        | invoked at runtime (before the main function is called) you need to
        | set a custom one by assigning to
        | <strong>Runtime.moduleUnitTester</strong> in the module constructor.
        | The one used in the above test-case simply returns
        | <strong>true</strong>, which allows the <strong>main</strong>
        | function to be called.

    p
        | <strong>Note:</strong> The <strong>getUnitTests</strong> trait is
        | not recursive. This means that calling it on a module will not
        | retrieve unittests which are nested in aggregates in that module.

    |!= h3(toc, "getvirtualindex-trait", "'getVirtualIndex' Trait")

    p
        | A <strong>getVirtualIndex</strong> trait has been introduced
        | for getting the index of a virtual function. You can use this trait
        | to get the index of a virtual method in the virtual method table:

    code
        pre
            | class C
            | {
            |     void foo() { }
            |     void bar() { }
            | }
            |
            | class D : C
            | {
            |     void doo() { }
            |     void doo(int) { }
            |     void doo(double) { }
            | }
            |
            | void main()
            | {
            |     /**
            |         Note that each class implicitly inherits from the
            |         Object class, so the following will most likely not
            |         begin with index 0.
            |     */
            |     pragma(msg, __traits(getVirtualIndex, D.foo));
            |     pragma(msg, __traits(getVirtualIndex, D.bar));
            |
            |    /**
            |        When dealing with overloads you can use the
            |        getOverloads trait to index into a specific method
            |    */
            |    alias dooOverloads = __traits(getOverloads, D, "doo");
            |
            |    pragma(msg, __traits(getVirtualIndex, dooOverloads[0]));
            |    pragma(msg, __traits(getVirtualIndex, dooOverloads[1]));
            |    pragma(msg, __traits(getVirtualIndex, dooOverloads[2]));
            | }

    |!= h3(toc, "isoverridefunction-trait", "'isOverrideFunction' Trait")

    p
        | The <strong>isOverrideFunction</strong> trait has been introduced
        | which indicates whether or not a function is overriding:

    code
        pre
            | class Base
            | {
            |     void foo() { }
            | }
            |
            | class Foo : Base
            | {
            |     override void foo() { }
            |     void bar() { }
            | }
            |
            | static assert (__traits(isOverrideFunction, Base.foo) == false);
            | static assert (__traits(isOverrideFunction, Foo.foo)  == true);
            | static assert (__traits(isOverrideFunction, Foo.bar)  == false);

    |!= h2(toc, "phobos-enhancements", "Phobos Enhancements")

    |!= h3(toc, "structural-typesafe-conversion", "Structural Typesafe Conversion")

    p
        | The structural typesafe conversion functions
        | <strong>wrap</strong> and <strong>unwrap</strong> were introduced
        | into
        - docLink("std.typecons");

    p
        | Sometimes you may want your class to be usable with a function
        | which expects a specific interface argument type, but you do not
        | necessarily want to edit the class to inherit that interface.
        | The class could also be implemented in another library for which
        | you do not have the source code, which means you wouldn't be
        | able to edit the inheritance list of that class.

    p
        | The new <strong>wrap</strong> function allows you to perform
        | a structural cast, allowing a class object to act as if it were
        | an object of another type. For example (note: for now please pass
        | the <strong>-allinst</strong> flag to dmd when compiling):

    code
        pre
            | import std.typecons;
            |
            | interface IDrawable
            | {
            |     void drawLine(int x1, int y1, int x2, int y2);
            | }
            |
            | // note: it does not inherit IDrawable.
            | class ImageDraw
            | {
            |     void drawLine(int x1, int y1, int x2, int y2) { }
            | }
            |
            | /** Draw a rectangle outline. */
            | void drawRect(IDrawable draw)
            | {
            |     draw.drawLine(  0,   0, 100,   0);
            |     draw.drawLine(100,   0, 100, 100);
            |     draw.drawLine(  0, 100, 100, 100);
            |     draw.drawLine(  0,   0,   0, 100);
            | }
            |
            | void main()
            | {
            |     auto imageDraw = new ImageDraw();
            |     // error: can't call this, ImageDraw is not an IDrawable.
            |     drawRect(imageDraw);
            |
            |     // perform a structural cast.
            |     IDrawable i = wrap!IDrawable(imageDraw);
            |     // and now imageDraw can act as an IDrawable.
            |     drawRect(i);
            | }

    p
        | The <strong>wrap</strong> function can also be used with classes
        | which define an <strong>opDispatch</strong> function, for example:

    code
        pre
            | import std.typecons;
            |
            | interface IDrawable
            | {
            |     void drawLine(int x1, int y1, int x2, int y2);
            |     void drawRect(int x, int y, int width, int height);
            | }
            |
            | class ImageDraw
            | {
            |     void opDispatch(string name, Args...)(Args args)
            |         if (name == "drawLine")
            |     {
            |         // ...
            |     }
            |
            |     void opDispatch(string name, Args...)(Args args)
            |         if (name == "drawRect")
            |     {
            |         // ...
            |     }
            | }
            |
            | /** Draw some shapes. */
            | void drawShapes(IDrawable draw)
            | {
            |     draw.drawLine(0, 100, 100, 0);
            |     draw.drawRect(0, 0, 100, 100);
            | }
            |
            | void main()
            | {
            |     auto imageDraw = new ImageDraw();
            |     IDrawable i = wrap!IDrawable(imageDraw);
            |     drawShapes(i);
            | }

    p You can unwrap a structurally cast object back to its original type:

    code
        pre
            | interface IDrawable
            | {
            |     void drawLine(int x1, int y1, int x2, int y2);
            | }
            |
            | class ImageDraw
            | {
            |     void drawLine(int x1, int y1, int x2, int y2) { }
            | }
            |
            | void main()
            | {
            |     auto imageDraw = new ImageDraw();
            |
            |     // perform a structural cast (note the simple UFCS syntax).
            |     IDrawable i = imageDraw.wrap!IDrawable;
            |
            |     // get back the original type (ditto, using UFCS syntax).
            |     ImageDraw draw = i.unwrap!ImageDraw;
            | }

    p And you can structurally cast to multiple interface types:

    code
        pre
            | import std.typecons;
            |
            | unittest
            | {
            |     interface IStoppable { void stop(); }
            |     interface IRunnable { void run(); }
            |
            |     class Timer
            |     {
            |         void run() { }
            |         void stop() { }
            |     }
            |
            |     auto timer = new Timer();
            |     auto obj = timer.wrap!(IStoppable, IRunnable);
            |
            |     // extract the individual structurally casted types
            |     // from the wrapped type
            |     IStoppable iStop = obj;
            |     IRunnable  iRun  = obj;
            |
            |     iRun.run();
            |     iStop.stop();
            | }

    |!= h3(toc, "more-pure-functions", "More Pure Functions")

    p
        | <strong>std.conv.to</strong> and <strong>std.string.format</strong>
        | are now pure functions:

    code
        pre
            | import std.conv;
            | import std.string;
            |
            | // this main is a pure function.
            | void main() pure
            | {
            |     string date = format("%s.%s.%s", 2013, 12, 10);
            |     int one = to!int(1.0);
            | }

    |!= h3(toc, "generic-strip-functions", "Generic 'strip' Functions")

    p
        | Generic <strong>strip/stripLeft/stripRight</strong> functions have
        | been added to
        - docLink("std.algorithm");

    p
        | The new generic strip functions allow you to not only strip strings
        | but also any other Input range (<strong>stripLeft</strong>) or
        | Bidirectional range (<strong>strip/stripRight</strong>), for example:

    code
        pre
            | import std.algorithm;
            |
            | void main()
            | {
            |     // strip whitespace.
            |     assert("  foobar  ".strip!(a => a == ' ')() == "foobar");
            |
            |     // an audio waveform.
            |     float[] data = [0.0, 0.0, 0.1, 0.5, 0.2];
            |
            |     // strip leading silence in the waveform.
            |     assert(data.strip!(a => a < 0.1)().length == 3);
            | }

    |!= h3(toc, "buffered-translate", "Buffered std.string.translate")

    p
        | To avoid implicit memory allocations <strong>translate</strong> in
        - docLink("std.string");
        | now features overloads which can take an output range to
        | write the contents to. For example:

    code
        pre
            | import std.array;
            | import std.string;
            |
            | void main()
            | {
            |     dchar[dchar] transTable = ['a' : '1', 'b' : '2', 'c': '3'];
            |
            |     // create our output range by using the Phobos Appender.
            |     auto buffer = appender!(dchar[])();
            |
            |     // don't remove any characters.
            |     auto toRemove = null;
            |
            |     translate("abcdef", transTable, toRemove, buffer);
            |     assert(buffer.data == "123def");
            |
            |     // or use a static array to avoid heap allocations.
            |     // if the buffer is too small an exception will be thrown.
            |     dchar[6] dbuffer;
            |     translate("abcdef", transTable, toRemove, dbuffer[]);
            |     assert(dbuffer == "123def");
            | }

    |!= h3(toc, "thisexepath-function", "thisExePath function")

    p
        | The <strong>thisExePath</strong> function has been introduced
        | for retrieving the executable path of the currently running
        | process:

    code
        pre
            | import std.file;
            | import std.stdio;
            |
            | void main(string[] args)
            | {
            |     // Prints the full path of the current running executable.
            |     // Note: this may, or may not be the same as args[0].
            |     // The content of args[0] is dependent of how
            |     // the application was invoked, thisExePath() is not.
            |     // It's also possible to access thisExePath()
            |     // from other parts of the code than main.
            |     writeln(thisExePath());
            | }

    |!= h3(toc, "new-regex-api", "New regex match/replace API")

    p
        | The api for <strong>match</strong> and <strong>replace</strong> in
        - docLink("std.regex");
        | has been changed.

    p
        | The old API based around <strong>"g"(=global)</strong> flag was
        | confusing and error prone. Moreover in some cases it was already
        | being overriden by a function as is the case with
        | <strong>std.regex.splitter</strong>.

    p
        | The new version ties the operation to the function in question,
        | thus being simpler to understand without extra context.
        | For the moment the "g" flag is kept working as is but the new
        | API always overrides it where applicable. Another addition in the
        | new API is an overload for the <strong>replace</strong>
        | family of functions to work directly with output ranges.

    p To understand the difference in the API compare 2 samples below.

    p Before 2.064:

    code
        pre
            | void main()
            | {
            |     import std.regex;
            |     import std.algorithm:
            |     import std.range;
            |     import std.stdio;
            |     import std.string;
            |
            |     auto m = "3.141592".match(`(\d+)\.(\d+)`);
            |     // m is a range of ranges
            |     assert(m.front.equal(["3.141592", "3", "141592"]));
            |
            |     // global vs non-global
            |     auto word = regex(`(\w)\w*`);
            |     auto gword = regex(`(\w)\w*`, "g");
            |     auto list = "tomatoes, potatoes, pineapple";
            |     // this will print only 'tomatoes',
            |     // which raised many questions
            |     foreach(item; list.match(word))
            |         writeln(item.hit);
            |
            |     // while this will print each of them
            |     foreach(item; list.match(gword))
            |         writeln(item.hit);
            |
            |     auto justFirst = replace!(
            |         m => toUpper(m[1]) ~ m[0].drop(1)
            |     )(list, word);
            |
            |     assert(justFirst == "Tomatoes, potatoes, pineapple");
            |
            |     auto allOfThem = replace!(
            |         m => toUpper(m[1]) ~ m[0].drop(1)
            |     )(list, gword);
            |
            |     assert(allOfThem == "Tomatoes, Potatoes, Pineapple");
            | }

    p After 2.064:

    code
        pre
            | void main()
            | {
            |     import std.regex;
            |     import std.algorithm:
            |     import std.range;
            |     import std.stdio;
            |     import std.string;
            |     auto m = "3.141592".matchFirst(`(\d+)\.(\d+)`);
            |     // m is simply a range of submatches
            |     assert(m.equal(["3.141592", "3", "141592"]));
            |
            |     auto word = regex(`(\w)\w*`);
            |     auto list = "tomatoes, potatoes, pineapple";
            |     // iterates over submatches so it will print 2 lines:
            |     // tomatoes
            |     // t
            |     foreach(item; list.matchFirst(word))
            |         writeln(item);
            |     // so just to get the whole match:
            |     assert(list.matchFirst(word).hit == "tomatoes");
            |
            |     // now there is no need to check if it has "g" option
            |     // it's crystal clear in the function name
            |     foreach(item; list.matchAll(word))
            |         writeln(item.hit);
            |
            |     auto justFirst = replaceFirst!(
            |         m => toUpper(m[1]) ~ m[0].drop(1)
            |     )(list, word);
            |
            |     assert(justFirst == "Tomatoes, potatoes, pineapple");
            |
            |     auto allOfThem = replaceAll!(
            |         m => toUpper(m[1]) ~ m[0].drop(1)
            |     )(list, word);
            |
            |     assert(allOfThem == "Tomatoes, Potatoes, Pineapple");
            |
            |     // NEW feature - if there is no need to allocate,
            |     // the resulting string
            |     // replacement may be just sent directly to
            |     // the wire (an OutputRange)
            |     auto sink = stdout.lockingTextWriter();
            |     replaceAllInto!(
            |         m => toUpper(m[1]) ~ m[0].drop(1)
            |     )(sink, list, word);
            | }

    p
        | The old API still works, even though eventual deprecation is
        | planned. Also note the new functionality in form of *Into
        | functions that forward the replacement directly to an output
        | range avoiding extra pressure on the heap.

    |!= h3(toc, "ctregex-lookahead", "ctRegex Lookahead")

    p
        | Compile-time <strong>ctRegex</strong> from
        - docLink("std.regex");
        | now supports lookaround just like run-time one:

    p
        | Now <strong>ctRegex</strong> supports full syntax spectrum of
        | run-time one except for set algebra inside of a character class.
        | For instance, the following now compiles and passes:

    code
        pre
            | void main()
            | {
            |     import std.regex;
            |     // a word, but not a title-cased ASCII
            |     // ?&lt;! inside of () means "negative lookbehind"
            |     auto pat = ctRegex!`\w+(?&lt;![A-Z][a-z]*)`;
            |     assert(!"Hello".match(pat));
            |     assert("good_bay".match(pat));
            | }

    |!= h2(toc, "dmd-compiler-regressions", "DMD Compiler Regressions Fixed")

    ol
        - bugItem(6014, "rt_finalize Segmentation fault , dmd 2.053 on linux & freebsd");
        - bugItem(10074, "segfault in dmd");
        - bugItem(10197, "[REG2.063] Cannot cast overloaded template property result");
        - bugItem(10212, "Segfault in mismatching delegate literal types");
        - bugItem(10215, "Regression (2.063 release): const causes wrong float calculation");
        - bugItem(10220, "`array` doesn't work with disabled default construction");
        - bugItem(10255, "When creating lib files, dmd no longer splits module into multiple obj files");
        - bugItem(10299, "[REG2.063] ICE with getting address of template");
        - bugItem(10330, "Regresfsion (2.063.2): __VERSION__ is set wrong");
        - bugItem(10337, "Error: mutable method glwtf.input.SignalWrapper!().SignalWrapper.Signal!().~this");
        - bugItem(10352, "Regression (2.063): --eval is broken in RDMD");
        - bugItem(10357, "std.typecons.Nullable!(SysTime).Nullable.__ctor!() error instantiating");
        - bugItem(10373, "cannot resolve forward reference (dmd2.063)");
        - bugItem(10375, "[REG2.061] private template from imported module hijacks a template type parameter(!)");
        - bugItem(10382, "Regression (2.059): ICE when catching illegal type");
        - bugItem(10394, "opBinaryRight!\"in\" and tuple");
        - bugItem(10397, "ICE on concatenating string with unexisted symbol");
        - bugItem(10425, "Link error with templates");
        - bugItem(10440, "shared library on osx: worked in 2.062, fails in 2.063 / 2.063.2");
        - bugItem(10441, "Static libraries too big");
        - bugItem(10456, "struct containing enum X, alias X this and a dynamic array no longer compiles since 2.063");
        - bugItem(10481, "out of memory error");
        - bugItem(10486, "Segfault on assigning `typeof(null)` to static array");
        - bugItem(10498, "`__traits(compiles, ...)` affect program behaviour");
        - bugItem(10503, "Octal enums don't work anymore");
        - bugItem(10505, "anonymous enum members cannot have different types");
        - bugItem(10537, "Forward reference error on 'yield' toy example.");
        - bugItem(10548, "[REG 2.064a] argument has no identifier");
        - bugItem(10558, "Assertion failure on struct.c:741");
        - bugItem(10561, "Regression (2.064 HEAD): anon enum members no longer have enum base type");
        - bugItem(10573, "Weird linking problem with associative array cast [DMD 2.63]");
        - bugItem(10577, "2.063 Mixin Regression (works with 2.062)");
        - bugItem(10579, "regression 062=>063: Cannot interpret TypeInfo at compile time");
        - bugItem(10592, "Regression of overloaded template function");
        - bugItem(10600, "regression(2.063.2) ICE: Assertion failed: (type->ty != Tstruct || ((TypeStruct *)type)->sym == this), function semantic, file struct.c, line 741.");
        - bugItem(10612, "Regression (2.064 HEAD): ICE on using enum as hash key with mutual module imports");
        - bugItem(10617, "contract with -profile -debug is not nothrow");
        - bugItem(10624, "[REG2.064a] ICE with tuple comparison");
        - bugItem(10626, "ICE with vector operation");
        - bugItem(10628, "[REG2.063] spurious \"hidden by\" deprecation warning");
        - bugItem(10669, "CTFE: using initialized static const class member no longer works");
        - bugItem(10673, "memory corruption in interpret.c");
        - bugItem(10682, "[ICE](cgcod.c line 1561) with ^^ operator and ulong");
        - bugItem(10684, "Refused array op with array literal");
        - bugItem(10687, "Refused cast from uint[] to array of uint-based enums at compile-time");
        - bugItem(10713, "[REG2.063] ICE with typeof(this.nonExistingField) in method signature");
        - bugItem(10721, "ICE with constructor with postcondition");
        - bugItem(10722, "Regression (2.064 git-head): Cannot interpret struct at compile-time");
        - bugItem(10726, "Bogus Circular Reference error if opEquals defined and has a loop");
        - bugItem(10727, "Regression (dmd-2.061) -- DMD dumps core");
        - bugItem(10734, "Assertion failure: '0' on line 1546 in file 'cast.c'");
        - bugItem(10736, "Regression (2.064 git-head): Instantiation failure triggered by module import and module order");
        - bugItem(10744, "[regression git-head v2.064] Rejects valid interface inheritance + wrong error message");
        - bugItem(10782, "dmd segfault with string mixin, CTFE, class, non-literal initializer");
        - bugItem(10788, "Regression: forward reference of enum member E from another module.");
        - bugItem(10789, "Struct destructor erroneously called");
        - bugItem(10804, "regression(2.063=>2.064) problem with Appender or dmd?");
        - bugItem(10808, "[REG2.064a] Incorrect typeid template argument should report error");
        - bugItem(10836, "'errors compiling the function' for optimized builds");
        - bugItem(10946, "Integer constant expression expected instead of...");
        - bugItem(10949, "CTFE ICE after indexing error");
        - bugItem(10964, "[REG][2.063] Static array assign/blit exception slips through catch block.");
        - bugItem(10981, "Contracts in pure class methods are useless");
        - bugItem(10994, "[REG] cannot declare statics struct with void-initialized static arrays");
        - bugItem(10998, "[REG 2.063] compile-time postblit call check is incorrectly suppressed.");
        - bugItem(11010, "Regression (2.063.2) typeid doesn't work on a member of an instance.");
        - bugItem(11039, "Undefined instantiation from circular imports");
        - bugItem(11054, "ICE: interpret.c:357: virtual void Statement::ctfeCompile(CompiledCtfeFunction*): Assertion `0' failed.");
        - bugItem(11062, "inline ice with alias this and opIndexAssign");
        - bugItem(11069, "DMD (github HEAD) Linker Regression");
        - bugItem(11081, "Win64: duplicate COMDAT with failed compilation with lambdas");
        - bugItem(11086, "dmd segfault");
        - bugItem(11105, "Error on struct with multidimentional static array initialization from its element");
        - bugItem(11117, "Pseudo module __entrypoint.d listed as dependency with -deps");
        - bugItem(11121, "Wrong parenthesis omission in ddoc output");
        - bugItem(11127, "std.range.cycle linker errors");
        - bugItem(11153, "Regression (2.064 git-head): ICE during a diagnostic for missing return type");
        - bugItem(11163, "[ICE](ctfeexpr.c line 355) with pragma(msg) of a wrong expression");
        - bugItem(11186, "Regression (2.061): Presence of Variant and const field invokes opAssign");
        - bugItem(11197, "[DMD 2.064a] Struct with postblit cannot be appended to an AA of arrays");
        - bugItem(11203, "extern (C++) classes broken");
        - bugItem(11220, "Regression in master: XXX__lambda2 cannot access frame of function XXX");
        - bugItem(11223, "inline ice with tuple assignment and if/else");
        - bugItem(11225, "Module dependency cycle causes import statements inside typeof() expressions inside templates to fail");
        - bugItem(11228, "alias this confuses static array copy");
        - bugItem(11230, "[REG2.064a] Inexact mangling for template function literal.");
        - bugItem(11233, "DMD HEAD very slow with large static array struct field");
        - bugItem(11237, "zero initializer emitted to read-only data segment, slow compilation");
        - bugItem(11242, "[REG2.064beta] Fails to infer template argument with inout");
        - bugItem(11245, "[REG 2.063] Can't access length of static arrays from within classes");
        - bugItem(11246, "[REG 2.063] Struct initialized in constructor is destroyed first");
        - bugItem(11256, "Error mixing struct with disabled default construction and templated with lambda struct");
        - bugItem(11261, "Can't infer types without explicit slice in foreach");
        - bugItem(11262, "std.regex.replace does not accept StaticRegex");
        - bugItem(11265, "Segfault while calling instance method of class defined inside struct");
        - bugItem(11267, "Resulting executable sizes varies a lot");
        - bugItem(11271, "[REG 2.063] auto ref opAssign + destructor + struct literal fails");

    |!= h2(toc, "dmd-compiler-bugs", "DMD Compiler Bugs Fixed")

    ol
        - bugItem(952, "Strange \"Error:\" prefix on some warning messages");
        - bugItem(1982, "[CTFE] Problems with compile-time null");
        - bugItem(2407, "function pointer as an enum's base type doesn't work");
        - bugItem(2486, "taking address of slice rvalue should not be allowed");
        - bugItem(3096, "EnumBaseType");
        - bugItem(3646, "Default values of function arguments are ignored when instantiating a template.");
        - bugItem(3866, "anonymous delegate with default parameters cross-talks to another anonymous delegate");
        - bugItem(4018, "__FILE__ and __LINE__ as default template parameters not set to instantiation point per spec");
        - bugItem(4481, "ICE(glue.c,!vthis->csym) or compiles, depending on the import statements order");
        - bugItem(4611, "stack overflow or ICE(cgcod.c) when static array of structs exceeds 16MB limit");
        - bugItem(4841, "-inline wrecks certain nested structs causing error \"*** is a nested function and cannot be accessed from ***\"");
        - bugItem(4899, "Ddoc: Warnings about stray parens do not include file and line numbers for module comments");
        - bugItem(5012, "ICE(cod3.c): handling a nested function in inline asm.");
        - bugItem(5655, "Lambda inside static foreach saves wrong value of counter");
        - bugItem(5842, "hash table corruption");
        - bugItem(5911, "Closure destroys the thrown Exception .");
        - bugItem(5988, "Template accepts instantiating an already-instantiated template type");
        - bugItem(6107, "ICE(expression.c) when a non-template member named '__ctor' exists in a struct, and the constructor is attempted to be invoked.");
        - bugItem(6169, "[CTFE] pure functions cannot compute constants using functions not marked as pure");
        - bugItem(6178, "Struct inside the AA are not init correctly");
        - bugItem(6310, "Missing \"template instantiation\" traceback when an error happens in the template parameter of an alias.");
        - bugItem(6461, "multiple definitions with typeid and multiobj");
        - bugItem(6711, "\"with\" doesn't work with \"alias this\"");
        - bugItem(6720, "ICE(cod1.c) casting return of void function to bool");
        - bugItem(6799, "ICE(type.c) involving AAs and pointers to structs");
        - bugItem(6906, "Cannot assign value into associative array if contains opAssign");
        - bugItem(7051, "Class member with un-@safe destructor gives confusing error");
        - bugItem(7156, "ICE(go.c): with 199 or 200 repeated integer increments, only with -O");
        - bugItem(7202, "Hole in type system still present for delegates");
        - bugItem(7254, "ICE(cod3.c) returning strings as static arrays");
        - bugItem(7436, "ICE(cg87.c) ubyte = ubyte op= float");
        - bugItem(7474, "ICE(cgcs.c) on instantiating a struct with field and destructor as tuple");
        - bugItem(7522, "ICE(interpret.c) Accessing a non-static member without this");
        - bugItem(7524, "D1: #line __LINE__ doesn't parse");
        - bugItem(7533, "Error with no line number with pure static ctor");
        - bugItem(7538, "All kinds of property functions should be called before getting their types inside typeof");
        - bugItem(7565, "ICE(cg87):202, postincrement of a double parameter, 64-bit only");
        - bugItem(7656, "ddoc misinterprets commented parentheses in an example");
        - bugItem(7715, "DDoc eats , , etc. inside d_code section");
        - bugItem(7727, "\"static initializer\" for non-static unions too");
        - bugItem(7746, "Error with 'TOK232' declaring enum of anonymous nested class type");
        - bugItem(7780, "Template mixin'd members do not properly overload");
        - bugItem(7806, "ICE(gloop.c) iterating with idouble, when compiling with -O");
        - bugItem(7848, "pure and nothrow ignored on unittest blocks");
        - bugItem(7892, "Compiler-generated struct copies can result in errors when ctor is @disable'd");
        - bugItem(7976, "ICE(backend/cg87.c)assignment btw two elements of dynamic array of complex number types");
        - bugItem(7988, "[CTFE] CTFE return values should be allowed in compile-time expressions");
        - bugItem(8119, "Cannot cast from void* to forwarded struct pointer");
        - bugItem(8179, "ICE(e2ir.c) with failed fixed size array cast");
        - bugItem(8253, "CTFE ICE: calling of member function of non-CTFE class variable");
        - bugItem(8285, "Issue with slice returned from CTFE function");
        - bugItem(8352, "Wrong \"__overloadset isn't a template\" error");
        - bugItem(8360, "Destruction of uninitialized temporary struct with assert");
        - bugItem(8361, "[ICE] (eh.c line 316) with struct with dtor in assert");
        - bugItem(8441, "mixin containing template functions causes compiler errors");
        - bugItem(8563, "Exception segfault");
        - bugItem(8579, "Default parameter appears a part of typeof().stringof of a function variable");
        - bugItem(8651, "Slice op Slice throws exceptions (not errors), and nothrow");
        - bugItem(8733, "Normalize -of path on Windows");
        - bugItem(8795, "mixing in \"switch\" or \"interface;\" makes dmd segfault");
        - bugItem(8911, "-property makes fullyQualifiedName fail for functions");
        - bugItem(8956, "Ability to break typesystem with constructor/postblit/destructor (e.g. modify immutable)");
        - bugItem(8977, "Ability to break typesystem with static struct initializer (e.g. modify immutable)");
        - bugItem(9017, "__traits(compiles, { enum e = ; }) is true but code doesn't compile");
        - bugItem(9235, "Template mixin doesn't allow to mixin non-conflicting overloads");
        - bugItem(9247, "Compiler accepts opaque struct returned by value from function pointer declaration.");
        - bugItem(9319, "Unexpected compiles __traits behaviour in a certain situation");
        - bugItem(9364, "[ICE] Error: CTFE internal error painting S*");
        - bugItem(9396, "Wrong line number when assigning nested enum to struct");
        - bugItem(9524, "Unittest ddocs fail to appear following ditto");
        - bugItem(9531, "__traits(parent, ...) does not work for types defined within a unittest block");
        - bugItem(9534, "Distributed CHM file lacks styling");
        - bugItem(9546, "getProtection trait does not work with mixin or getMember");
        - bugItem(9571, "link error due to using unique ids in anonymous funcliteral");
        - bugItem(9578, "\"is a nested function and cannot be accessed from\" problem");
        - bugItem(9586, "Win64 5/6/7 struct returns");
        - bugItem(9628, "Lambda in foreach loop Vs. lambda in static foreach loop");
        - bugItem(9634, "[CTFE] wrong code concatenating arrays of structs");
        - bugItem(9665, "Structure constant members can not be initialized if have opAssign");
        - bugItem(9710, "Pointer enums crash dmd");
        - bugItem(9733, "Hello world segfaults on Debian x86_64 with -m64");
        - bugItem(9782, "implementing RTInfo!T causes errors for deprecated types");
        - bugItem(9859, "Cannot use inout in delegate");
        - bugItem(9904, "typeof(null) can be casted to aggregate type if .sizeof equals size of pointer");
        - bugItem(9921, "Enum variables of type void should be illegal");
        - bugItem(9923, "[ICE] (interpret.c line 167) with countUntil on Typedef[]");
        - bugItem(9938, "ICE using global interface variable in CTFE");
        - bugItem(9954, "Runtime wrong code with global interface var created in CTFE");
        - bugItem(9982, "ICE on CTFE for pointer dereference");
        - bugItem(10007, "function overrides but is not covariant");
        - bugItem(10037, "Compiler should not generate opEquals method implicitly");
        - bugItem(10064, "opDollar called on garbage");
        - bugItem(10065, "Compiler fails without error message for tuple map");
        - bugItem(10079, "Built-in generated opAssign should be pure nothrow @safe by default");
        - bugItem(10082, "ICE(e2ir.c) Multiple mixin template instantiations are not checked");
        - bugItem(10083, "Insufficient IFTI/eponymous template specification");
        - bugItem(10086, "ICE(glue.c) or wrong code on passing variable as template value parameter");
        - bugItem(10094, "NRVO with static array return should work");
        - bugItem(10099, "Diagnostic for disabled default construction should improve");
        - bugItem(10113, "Can't use an enum : string in a switch statement");
        - bugItem(10141, "wrong error message with Tuple!(int) : Error: static assert \"Cannot put a char[] into a Appender!(string)\"");
        - bugItem(10156, "Can't handle usage of TypeTuple argument in templated function");
        - bugItem(10196, "RDMD: RDMD can't be used from MSys");
        - bugItem(10198, "CTFE: Wrong code for multi-dimensional block assignment");
        - bugItem(10208, "Module-level const/immutable variables with initialization value don't support UDAs");
        - bugItem(10211, "CTFE: Support casts from S** to D**, if S* -> D* is supported.");
        - bugItem(10214, "Incorrect \"element-wise assignment is better\" warning");
        - bugItem(10243, "[CTFE] Wrong-code on passing dereferenced array pointer by ref");
        - bugItem(10244, "ICE: expression.c:8364: virtual Expression* CallExp::semantic(Scope*): Assertion `td' failed");
        - bugItem(10249, "incorrect mangling for overloaded symbol");
        - bugItem(10252, "CTFE: Should generate error for shifts outside valid range");
        - bugItem(10254, "Purity correctness is broken with constructor");
        - bugItem(10273, "ICE(ctfeexpr.c): using CTFE after error in struct default values");
        - bugItem(10274, "DMD 2.063 produces broken binaries");
        - bugItem(10275, "CTFE: Allow const casts of struct literals");
        - bugItem(10277, "Incorrect error file and line on redeclaration of TypeInfo");
        - bugItem(10279, "Calling a typesafe variadic @trusted function from an @safe function results in an error.");
        - bugItem(10280, "CTFE: Circular variable initializers should be detected properly");
        - bugItem(10283, "ICE(interpret.c): passing struct with failed initalizer to CTFE");
        - bugItem(10288, "Direct lambda call and purity inference bug");
        - bugItem(10289, "compiler should infer nothrow even if Error is thrown");
        - bugItem(10296, "Nested template function call and purity inference bug");
        - bugItem(10298, "CTFE fails with array literal initialization");
        - bugItem(10302, "Package module conflicts with package name");
        - bugItem(10319, "@safe/pure/nothrow error should print fully qualified name");
        - bugItem(10325, "ddoc: template constraints inconsistently shown in generated html");
        - bugItem(10327, "Missing 'package.d' for DIP37 needs a better error message");
        - bugItem(10341, "Range case without an associated switch statement crashes DMD");
        - bugItem(10343, "Cannot resolve a forward reference to a template inside global typeof");
        - bugItem(10344, "Exiting _Dmain should flush all FILE*s and return nonzero on failure");
        - bugItem(10346, "No line number error with undefined template identifier");
        - bugItem(10354, "DIP37: ICE with using indirectly imported template through package.d");
        - bugItem(10359, "Pointer slicing allowed in @safe mode");
        - bugItem(10381, "Nonsense associative array comparison");
        - bugItem(10386, "Package import feature breaks with static libraries");
        - bugItem(10389, "Infinite recursion on printing self-referential StructLiteralExp");
        - bugItem(10390, "ICE on printing ClassReferenceExp");
        - bugItem(10405, "redundant \"expression has no effect\" error when returning non-void in void function");
        - bugItem(10414, "Delegate arguments for lazy variadic functions are only inferred in first argument");
        - bugItem(10415, "Bad error message with const property of const class instance");
        - bugItem(10418, "bad error message: \"not a property\"");
        - bugItem(10419, "Unhandled exception in dmd after correct error message");
        - bugItem(10421, "'package' access should work with package module");
        - bugItem(10429, "RDMD: --loop option doesn't work due to symbol conflict");
        - bugItem(10431, "ICE(DMD 2.063) in struct.c:741");
        - bugItem(10432, "RDMD: --dry-run option tries to read non-existent file");
        - bugItem(10433, "Array sum operation in function template");
        - bugItem(10435, "rdmd doesn't support the -op argument.");
        - bugItem(10451, "Array of pointers to opaque struct gives forward reference errors.");
        - bugItem(10452, "CTFE: Cannot compare delegates with == or 'is'");
        - bugItem(10462, "interface thunk doesn't preserve EBX");
        - bugItem(10479, "cannot pass implicitly to base class casted result to out contract by ref");
        - bugItem(10495, "Incorrect \"initializer required\" error using lambdas in class with fields with disabled default construction");
        - bugItem(10497, "Opaque structs cannot be dereferenced in pointer to pointer types");
        - bugItem(10504, "Tuple error: no property 'offsetof' for type 'int'");
        - bugItem(10506, "Purity should not be checked in a mixin statement");
        - bugItem(10519, "Stray-paren in doc-unittest code generates wrong document");
        - bugItem(10526, "opDispatch with IFTI should not disable UFCS");
        - bugItem(10534, "Addition and subtraction of delegates allowed");
        - bugItem(10539, "[REG][2.063] Implicit pointer to array dereference for .ptr property fails");
        - bugItem(10542, "implicitly generated class ctor doesnt inherit base class ctor attributes");
        - bugItem(10551, "[CTFE] Wrong-code on passing dereferenced array pointer by ref 2");
        - bugItem(10568, "CTFE rejects function pointer safety casts");
        - bugItem(10583, "DMD 2.063 dumps core with mixins involving __traits(getProtection, ..");
        - bugItem(10595, "Using alias this and a hash generates wrong code");
        - bugItem(10596, "A method with out contract and auto return type causes segfault");
        - bugItem(10597, "opDollar not callable in static constext");
        - bugItem(10599, "CTFE: assert failure interpret.c 310");
        - bugItem(10609, "Refused UFCS in __traits(compile)");
        - bugItem(10610, "interpret.c:4067 Assertion Failure");
        - bugItem(10618, "Template instance member access disallowed in dynamic array allocation");
        - bugItem(10630, "Structs with disabled default construction can't be used as `out` parameters");
        - bugItem(10633, "Win64: wrong codegen with %=");
        - bugItem(10634, "Win64: wrong codegen with .init of small structs");
        - bugItem(10639, "Win64: wrong optimizer codegen with struct literal with complex fields");
        - bugItem(10642, "Win64: wrong codegen comparing different sized integer arguments");
        - bugItem(10646, "No front-end error for invalid casting dynamic array/static array to class reference");
        - bugItem(10651, "Throwing non-Throwable object causes ICE");
        - bugItem(10676, "excessive compilation times with optimized PIC build");
        - bugItem(10677, "Win64: cfloat return value not forwarded correctly as function argument");
        - bugItem(10678, "Win64: wrong code passing small fixed sized array as function argument");
        - bugItem(10694, "wrong purity check for static variables with impure destructor");
        - bugItem(10695, "__MODULE__ in string mixin crashes compiler");
        - bugItem(10715, "negated bit test (bt) not recognized by optimizer");
        - bugItem(10735, "Buffer overflow bug in symbol_generate()");
        - bugItem(10746, "Win64: corrupt debug info with very long symbols");
        - bugItem(10752, "accessing a private cached symbol a second time doesn't cause an error in __traits(compiles, ...)");
        - bugItem(10758, "Unsound type checking for inout.");
        - bugItem(10761, "DMD crashes on unspecified inout matching.");
        - bugItem(10768, "DMD does not show deprecation message for missing 'override' keyword");
        - bugItem(10781, "ctRegex! throws a huge error");
        - bugItem(10783, "ICE and bad diagnostics when using non-existent symbols in switch and with statements");
        - bugItem(10792, "Bad diagnostic on new eponymous enum template syntax");
        - bugItem(10793, "Forward reference errors casting from void* to opaque struct pointer");
        - bugItem(10809, "[REG] darwin 32 dmd release broken");
        - bugItem(10811, "Order dependent IFTI failure");
        - bugItem(10813, "ICE(DMD2.063) template.c:6040: Identifier* TemplateInstance::genIdent(Objects*): Assertion `global.errors' failed");
        - bugItem(10834, "cannot use cast(void)expr if the type of expr is a struct");
        - bugItem(10840, "[CTFE] *this._data.arr is not yet implemented at compile time");
        - bugItem(10842, "Some integer casts wrongly remove side-effect of the operand.");
        - bugItem(10857, "ICE(glue.c,bugzilla 2962?) or compiles, depending on the files order");
        - bugItem(10858, "CTFE wrong code for comparison of array of pointers");
        - bugItem(10862, "Assignment inside if condition still sometimes accepted");
        - bugItem(10869, "Ddoc mark methods with \"const\" twice");
        - bugItem(10870, "Ddoc adds \"abstract\" to interfaces");
        - bugItem(10937, "struct inside union gives uninitialized error in CTFE");
        - bugItem(10942, "ICE on 1087+ initializers (Internal error: backend\\cgcv.c 203)");
        - bugItem(10944, "[ICE](interpret.c line 310) with arith operation on missing variable");
        - bugItem(10947, "const out parameter is not properly rejected");
        - bugItem(10953, "Attribute inheritance needs to apply to contracts, too");
        - bugItem(10968, "array element copy (1-N and N-N) ignores postblit attributes");
        - bugItem(10969, "Variadic template parameter re-use in function signature");
        - bugItem(10970, "Segfault in a simple test compiled without -g.");
        - bugItem(10980, "static initialization of immutable structs with disabled postblit fails");
        - bugItem(10984, "Frame access diagnostic should improve");
        - bugItem(10989, "[CTFE] Uncaught exception messages are not pretty printed if message wasn't literal");
        - bugItem(10990, "Passing in a module as a mixin to __traits(getUnitTests) behaves differently than passing in the module directly.");
        - bugItem(10992, "Trait getUnitTests skips first test if aggregate contains multiple tests.");
        - bugItem(10993, "mangling of voldemort types with lambdas changes during return type inference");
        - bugItem(10995, "CTFE failures for structs with void initialized members");
        - bugItem(11002, "Compiler doesn't see std.sys.linux.epoll.");
        - bugItem(11075, "ICE(struct.c) after gagged error in struct field initializer");
        - bugItem(11125, "UFCS instantiation of template causes template constraint to be skipped");
        - bugItem(11132, "Odd diagnostic with C-style struct initializer when union field is present");
        - bugItem(11134, "Inconsistent postblit call count depends on the pointer size");
        - bugItem(11136, "ICE on incorrect module declaration");
        - bugItem(11137, "Stack overflow on invalid output path");
        - bugItem(11141, "Missing .pdb file with phobos64");
        - bugItem(11142, "Wrong error message \"no size yet for forward reference\" for opaque struct");
        - bugItem(11144, "Better diagnostic for typeid symbol");
        - bugItem(11145, "Duplicated deprecation message \"use of typedef is deprecated;\"");
        - bugItem(11146, "Wrong line number of \"identity assignment operator overload is illegal\"");
        - bugItem(11147, "Nested structs in a union are not correctly initialized");
        - bugItem(11151, "Undetected overlapping initialization");
        - bugItem(11159, "[CTFE] Integer exponentiation give incorrect values");
        - bugItem(11164, "wrong dependencies generated when compiling with -main");
        - bugItem(11182, "dmd crashes on compiling regex");
        - bugItem(11187, "A small transitive const bug on struct copying");

    |!= h2(toc, "dmd-compiler-enhancements", "DMD Compiler Enhancements")

    ol
        - bugItem(658, "struct pointers in with()");
        - bugItem(767, "compiler shall print dependencies and pragma(lib)");
        - bugItem(5943, "Power expression optimisation for 2^^unsigned");
        - bugItem(8635, "Allow postfix expressions for new");
        - bugItem(9022, "IFTI should support enclosing type/scope deduction");
        - bugItem(9097, "Value range propagation to disable some array bound tests");
        - bugItem(9565, "Index of static array should not print literal suffix");
        - bugItem(10022, "Importing packages");
        - bugItem(10117, "Support C++ class-scope static variables");
        - bugItem(10236, "Ddoc: Warning on wrong parameter names");
        - bugItem(10334, "ddoc should prefer simple syntax for template instantiations with one parameter");
        - bugItem(10367, "DDoc should output enum base type");
        - bugItem(10688, "Misleading error message when attempting a \"private override\"");
        - bugItem(10724, "Allow slice of string literal to convert to const(char)*");
        - bugItem(10991, "Implement trait to get vptr index of a method.");
        - bugItem(11088, "Diagnostics for enum member overflows should improve");
        - bugItem(11257, "Allow whole implicit conversion if one or more overlapped field could.");

    |!= h2(toc, "phobos-regressions", "Phobos Regressions Fixed")

    ol
        - bugItem(10218, "std.typecons.opAssign is not CTFEable");
        - bugItem(10268, "[REG2.063] std.typecons.Nullable!JSONValue - error instantiating");
        - bugItem(10355, "fullyQualifiedName doesn't work with enums");
        - bugItem(10468, "Regression (2.063): Lockstep no longer works with iota");
        - bugItem(10499, "[REG 2.064] retro is no longer CTFE-able");
        - bugItem(10686, "No [] operator overload for immutable Tuple");
        - bugItem(10866, "Regression (2.064 git-head) Massive compiler slowdown");
        - bugItem(10896, "currently tools/ddemangle doesn't compile on git master");
        - bugItem(10906, "[2.064 git-head] Out of memory compiling Phobos on Windows");
        - bugItem(10913, "[2.064 git-head] regex/demange compilation failure");
        - bugItem(11009, "Regression (2.064 git-head): DMD consumes huge memory when it compiles enum containing many items");
        - bugItem(11057, "[REG2.064dev] New std.uni has icmp() partly broken");
        - bugItem(11165, "std.typecons._d_toObject conflicts with std.signals._d_toObject");
        - bugItem(11283, "[REG 2.064] assert in std/windows/syserror.d");

    |!= h2(toc, "phobos-bugs-fixed", "Phobos Bugs Fixed")

    ol
        - bugItem(2717, "alloca(0) leaves stack unaligned on OSX");
        - bugItem(4575, "Uses of deprecated delete statement in D2 Phobos");
        - bugItem(5224, "std.algorithm.remove!(SwapStrategy.unstable) doesn't work");
        - bugItem(5378, "File.byLine terminator string");
        - bugItem(5630, "array() of iterable of immutable items");
        - bugItem(5692, "Printing complex numbers with negative imaginary part");
        - bugItem(5942, "Bitfields are overwritten erroneously");
        - bugItem(6342, "Tuple field access problem in pure function");
        - bugItem(6407, "take(map) problem");
        - bugItem(6686, "bitmanip bitfields are broken at 64 bits");
        - bugItem(6893, "Write of enum member represented with ubyte or ulong");
        - bugItem(7756, "iota(const doubles) problem");
        - bugItem(8124, "std.net.isemail not included in phobos.lib");
        - bugItem(8330, "std.algorithm.find doesn't handle reference type ranges correctly");
        - bugItem(8474, "bitfields doesn't work with 32 bit fields");
        - bugItem(8806, "fullyQualifiedName!T does not work for inner types");
        - bugItem(9310, "escapeShellCommand unittests are never run");
        - bugItem(9384, "std.socket: UnixAddress broken on Linux and others");
        - bugItem(9548, "BigInt: Wrong comparison result: BigInt(\"-1\") > long.min");
        - bugItem(9557, "std.array.array of array of immutable structs");
        - bugItem(9559, "Range of Nullable doesn't work with std.array.array");
        - bugItem(9579, "std.regex.replace format argument should not require same constness as target string");
        - bugItem(9599, "File.byLine doesn't function properly with take");
        - bugItem(9607, "std.random.randomShuffle and partialShuffle don't work with Xorshift");
        - bugItem(9629, "toUpperInPlace doesn't work properly with unicode characters");
        - bugItem(9725, "std.string.format does wasteful UTF decoding");
        - bugItem(9824, "Emplace is broken");
        - bugItem(9967, "ParameterIdentifierTuple broken for setters");
        - bugItem(10017, "Can not assign to a Variant another Variant holding a bigger structure");
        - bugItem(10078, "std.string.indexOf(Char[], dchar, CaseSensitive) fails at compile time");
        - bugItem(10130, "map of iota with const step");
        - bugItem(10161, "std.datetime unittest failure \"Libya Standard Time\"");
        - bugItem(10188, "Wrong Document Comment on std.format.d(176)");
        - bugItem(10216, "Bad warning in std.process.kill");
        - bugItem(10265, "RandomSample fails when passed an InputRange as input");
        - bugItem(10269, "RandomSample should use popFrontExactly, not popFrontN, when skipping across input range");
        - bugItem(10322, "std.random.RandomSample.index() returns wrong value if called before front()");
        - bugItem(10347, "buildPath returns relative path when joining absolute with relative path");
        - bugItem(10348, "isRooted is either wrong or poorly specified");
        - bugItem(10377, "std.typecons.wrap doesn't consider private members");
        - bugItem(10408, "Two-function std.algorithm.reduce of a const array");
        - bugItem(10426, "Improve code coverage of std.random unittests");
        - bugItem(10463, "dirEntries() segfaults on paths the user does not have access to");
        - bugItem(10469, "WinAPI declarations in std.process should be moved to core.sys.windows.windows");
        - bugItem(10474, "When takeExactly returns a new range type, it fails to propagate all relevant attributes");
        - bugItem(10510, "enforce can't take an extern(C) function to call");
        - bugItem(10517, "readln(Char)(Char[] buf) accepts non-mutable buffers");
        - bugItem(10536, "std.typecons.wrap doesn't work with a class that defines opCast");
        - bugItem(10543, "std.algorithm.map incorrectly uses source range length for narrow strings");
        - bugItem(10550, "Xorshift32 and Xorshift160 do not generate uniformly-distributed random numbers");
        - bugItem(10570, "Example of `how` function for AutoImplement should work for non-abstract class");
        - bugItem(10601, "std.path.setExtension leaves trailing dot if extension is empty");
        - bugItem(10607, "DirEntry has no constructor");
        - bugItem(10608, "std.typecons.RefCounted has very poor diagnostics");
        - bugItem(10644, "Win64: wrong code when passing arguments through ...");
        - bugItem(10647, "AutoImplement should implement overridden member functions with 'override' attributes");
        - bugItem(10660, "ddoc on std.algorithm: Cheat sheet description for 'filter' is wrong");
        - bugItem(10680, "BigInt uses deprecated std.traits.unsigned");
        - bugItem(10732, "Example code for std.utf.toUTFindex does not work");
        - bugItem(10773, "std.algorithm.splitter produces infinite range with empty delimiter");
        - bugItem(10796, "std.regex: ctRegex bug with '.' and $ in multi-line mode");
        - bugItem(10797, "std.regex: ctRegex \"codegen\" bug with certain nested infinite loops");
        - bugItem(10799, "std.regex: ctRegex lookahead support");
        - bugItem(10800, "ParameterDefaultValueTuple returns an empty string for default values in property functions.");
        - bugItem(10801, "std.regex: support for lookbehind in ctRegex");
        - bugItem(10802, "std.regex: ctRegex fails to compile with backreference");
        - bugItem(10874, "std.conv.to should support conversion from ulong to int-based enum");
        - bugItem(10893, "Numerous DDoc parameter warnings in Phobos (as found by 10236)");
        - bugItem(10898, "LockingTextWriter segfaults in .init state");
        - bugItem(10951, "EnumMembers should document about returning duplicate members");
        - bugItem(11068, "raw formatting of chars and strings is wrong");
        - bugItem(11089, "std.string.toUpper doesn't work with 1:m mappings");
        - bugItem(11152, "formatChar doesn't handle `\0`");
        - bugItem(11160, "Bitfield compilation error with degenerate bitfields of length 32 & 64");
        - bugItem(11194, "std.container.Array.reserve calls opAssign on uninitialized data");
        - bugItem(11222, "std.string.isNumeric accepts a \"+\"");
        - bugItem(11232, "Windows sysErrorString only supports ASCII");

    |!= h2(toc, "phobos-enhancements", "Phobos Enhancements")

    ol
        - bugItem(4120, "bigint implicit cast too bool");
        - bugItem(4124, "toString() for BitArray");
        - bugItem(4850, "std.conv.to isn't pure");
        - bugItem(6154, "std.math.abs on std.complex numbers too");
        - bugItem(6381, "math.floor, math.ceil are not pure functions.");
        - bugItem(6626, "std.complex.expi()");
        - bugItem(9699, "strip functions should have stripLeft/stripRight counterparts and be generic");
        - bugItem(10092, "Renaming std.range.chunks as std.range.chunked");
        - bugItem(10314, "Add std.traits.signed");
        - bugItem(10538, "std.typecons.wrap should consider opDispatch");
        - bugItem(10621, "dirEntry is (now) useless");
        - bugItem(10717, "std.ascii.toLower and toUpper should return char instead of dchar and avoid me to use a bad cast(char)");
        - bugItem(10868, "std.string.translate should take an optional buffer");
        - bugItem(10881, "Support %f formatting for a std.complex.complex");
        - bugItem(10909, "std.conv.to!(bool)(int): conversion from integer to bool");
        - bugItem(11020, "Add function for getting the current executable path");
        - bugItem(11123, "std.getopt should support functions");

    |!= h2(toc, "druntime-regressions", "Druntime Regressions Fixed")

    ol
        - bugItem(10976, "thread_joinAll after main exit performed too late");

    |!= h2(toc, "druntime-bugs-fixed", "Druntime Bugs Fixed")

    ol
        - bugItem(6210, "Associative array with array key often cannot be equated.");
        - bugItem(6372, "data loss due to possible bug in garbage collector");
        - bugItem(7741, "getHash inconsistent for const(char)[] vs. char[] and string");
        - bugItem(8435, "BigInts don't work well in associative arrays");
        - bugItem(9783, "profiling recursive function calls yields bad tree timing");
        - bugItem(9852, "Empty associative array crashes program");
        - bugItem(10027, "demangled name format of local function is wrong");
        - bugItem(10118, "BigInt as associative array key wrong behavior");
        - bugItem(10323, "getAMDcacheinfo needlessly allocates");
        - bugItem(10420, "Incorrect function attributes in `core.exception`");
        - bugItem(10436, "The runtime should print stack traces to stderr (like on *nix), not stdout");
        - bugItem(10457, "_d_toObject might fail with shared libraries");
        - bugItem(10593, "array's reserve/capacity go haywire if length has been changed prior");
        - bugItem(10711, "shared phobos library should not depend on _Dmain");
        - bugItem(10720, "ICE with is(aaOfNonCopyableStruct.nonExistingField)");
        - bugItem(10894, "Numerous DDoc parameter warnings in druntime (as found by 10236)");

    |!= h2(toc, "druntime-enhancements", "Druntime Enhancements")

    ol
        - bugItem(9190, "Vector operations are not optimized for x86_64 architecture");

    |!= h2(toc, "installer-bugs-fixed", "Installer Bugs Fixed")

    ol
        - bugItem(10062, "installers should use CDN");

    |!= h2(toc, "website-bugs-fixed", "Website Bugs Fixed")

    ol
        - bugItem(9533, "CHM generation crashes");
        - bugItem(10031, "Link to old wiki on dlang.org");
        - bugItem(10230, "Duplicated buttons for runnable examples");
        - bugItem(10410, "Improve cast(void) documentation");
        - bugItem(10461, "Incorrect example of \"depend on order of evaluation\" expression");
        - bugItem(10565, "Level-5 titles are missing in Language reference");
        - bugItem(10605, "Lambda grammar is not sufficient");
        - bugItem(10885, "[std.range] refRange is missing from module description tables");
        - bugItem(11001, "Need documentation for __traits(getVirtualIndex)");
        - bugItem(11036, "Document that .stringof should not be used for code generation");

append extra-sidebar
    |!= toc.write("On This Page")
