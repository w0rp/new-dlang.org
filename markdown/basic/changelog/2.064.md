<h1>Change Log &ndash; v2.064</h1>

<h2 id="language-enhancements">Language Enhancements</h2>

<h3 id="package-modules">Package Modules</h3>

The new package import feature allows you to define a library module which has
the purpose of publicly importing any other modules in that library. The user
can then simply import this one module and use the library as if the user
import all the modules at once. For example:

**libweb/client.d:**

```
module libweb.client;

void runClient() { }
```

**libweb/server.d:**

```
module libweb.server;

void runServer() { }
```

**libweb/package.d:**

```
module libweb;

public import libweb.client;
public import libweb.server;
```

Notice that the package module must always have the file name **package.d**.
The module name is the qualified name of the package. The user then uses the
standard import syntax to import a package module, simply using the module
declaration name to import the package:

**test.d:**

```
module test;

import libweb;

void main()
{
    startServer();
    startClient();
}
```

The following is an example of a package module of a sub-package:

**libweb/utils/package.d:**

```
// fully qualified name of the package, not just "utils"!
module libweb.utils;

// publicly import modules from within 'libweb.utils'
public import libweb.utils.conv;
public import libweb.utils.text;
```

To import this subpackage, use the standard module import declaration:

```
module test;

import libweb.utils;

void main()
{
}
```

<h4 id="package-modules-rationale">Rationale</h4>

Until now *public import* modules were implementable, but only by convention.
The user would typically have to import a specific module specified by the
library author, e.g.  **libweb.all** or **libweb._**.  Introducing the package
import feature standardizes this common convention of library authors

<h3 id="eponymous-template-syntax">Eponymous Template Syntax</h3>

The new eponymous template syntax allows you to write shorter templates without
having to explicitly define and repeat the template name when using traditional
eponymous templates.  For example, before 2.064 eponymous templates were
written and used like the following:

```
template Tuple(T...) { alias Tuple = T; }

template isIntOrFloat(T)
{
    static if (is(T == int) || is(T == float))
        enum isIntOrFloat = true;
    else
        enum isIntOrFloat = false;
}

void main()
{
    alias Tup = Tuple!(int, float, string);
    // int is an int or a float
    static assert(isIntOrFloat!(Tup[0]));
    // float is an int or a float
    static assert(isIntOrFloat!(Tup[1]));
    // string is neither an int nor a float
    static assert(!isIntOrFloat!(Tup[2]));
}
```

With the new eponymous syntax, the implementation code becomes much simpler:

```
alias Tuple(T...) = T;

enum isIntOrFloat(T) = is(T == int) || is(T == float);

void main()
{
    alias Tup = Tuple!(int, float, string);
    // int is an int or a float
    static assert(isIntOrFloat!(Tup[0]));
    // float is an int or a float
    static assert(isIntOrFloat!(Tup[1]));
    // string is neither an int nor a float
    static assert(!isIntOrFloat!(Tup[2]));
}
```

Notice how you need to start the declaration of such a template with an
**alias** or **enum**, rather than starting it with the keyword **template**.

<h4 id="eponymous-template-syntax-limitations">Limitations</h4>

Currently you cannot define template constraints for these types of templates.
This limitation may be lifted in a future release.

<h3 id="postfix-after-new">Postfix Expressions After 'new'</h3>

Before 2.064, you could not both instantiate a new class and call a method or
access a property of the object without having to wrap the **new** expression
in parentheses:

```
class Server
{
    this(string[] args) { }
    void run() { }
}

void main(string[] args)
{
    (new Server(args)).run();
}
```

In 2.064 this limitation has been lifted, allowing you to write the code as
follows:

```
class Server
{
    this(string[] args) { }
    void run() { }
}

void main(string[] args)
{
    new Server(args).run();
}
```

**Note:** When instantiating a class with the default constructor, you must
insert an empty set of parentheses before accessing a field or calling a method
on the object:

```
class Server
{
    this() { }
    void run() { }
}

void main()
{
    // error
    new Server.run();
    // ok
    new Server().run();
}
```

<h3 id="ifti-enclosing-scope">IFTI & Enclosing Scope</h3>

Implicit Function Template Instantiation now supports enclosing type/scope
deduction. This allows you to write code such as the following:

```
struct A
{
    struct Foo { }
}

struct B
{
    struct Foo { }
}

/**
Templated function which expects
the second argument to be of type 'Foo',
which is a nested in the type 'T'.
*/
void call(T)(T t, T.Foo foo) { }

void main()
{
    auto a = A();
    auto a_f = A.Foo();
    // ok
    call(a, a_f);

    auto b = B();
    auto b_f = B.Foo();
    // ok
    call(b, b_f);

    // fails: b_f is typed as B.Foo, not A.Foo
    call(a, b_f);
}
```

This <abbr title="Implicit Template Function Instantiation">IFTI</abbr>
feature also allows you to retrieve the module of a symbol, by using an
**alias** template parameter, rather than a type one:

```
module my_module;

struct A
{
    struct B { }
}

void foo(alias Mod)(Mod.A, Mod.A.B)
{
    // 'Mod' is deduced to be the module 'my_module'
    // which encloses the struct 'A'
    static assert(__traits(isSame, Mod, my_module));
}

void main()
{
    A a;
    A.B b;
    // ok
    foo(a, b);
}
```

<h3 id="ddoc-symbol-warning">DDoc Symbol Mismatch Warning</h3>

DDoc can now warn the user when the symbol names in a ddoc comment do not match
the actual code. Here is an example documented function, where the parameter
names are wrongly documented.

```
/**
    This is the sum function.

    params:
        x = The first parameter
        y = The second parameter
*/
int sum(int a, int b)
{
    return a + b;
}
```

Generating the documentation with warnings enabled will emit the following:

```
dmd -D -c -w test.d
```

```
Warning: Ddoc: function declaration has no parameter 'x'
Warning: Ddoc: function declaration has no parameter 'y'
```

This feature can help ensure that the documentation for library code is always
kept up-to-date.

**Note:</strong> Remember to use the <strong>-w** switch when building the
documentation with the **-D** switch in order to enable these warnings.

<h3 id="string-literal-charp">Slicing String Literals and char*</h3>

To help ease interacting with C libraries which expect strings as
null-terminated pointers, slicing string <strong>literals</strong> (*not*
variables!) will now allow the implicit conversion to a <strong>char</strong> pointer:

```
extern(C) void call(const(char)* str) { }

void main()
{
    const(char)* abc = "abc";
    // already previously allowed
    call(abc);

    const(char)* ab = "abc"[0 .. 2];
    // allowed in 2.064
    call(ab);
}
```

<h3 id="templates-and-overloads">Templates and Overloads</h3>

Templated and non-template functions can now be overloaded against each other:

```
auto foo(int n) { return 1; }
auto foo(T)(T t) { return 2; }

void main()
{
    assert(foo(100) == 1);
    assert(foo("a") == 2);

    // Integer literal 10L can be converted to int
    // without loss of precision.
    // Then the call matches to foo(int n).
    assert(foo(10L) == 1);

    // A runtime variable 'num' typed long
    // is not implicitly convertible to int.
    // Then the call matches to foo(T)(T t).
    long num = 10L;
    assert(foo(num) == 2);
}
```
<h3 id="cross-moduletemplate-overloads">Cross-module Template Overloads</h3>

Template declarations are now overloadable just like regular function
declarations. Templates with matching names from multiple modules will
introduce an overload set:

```
module a;

template Traits(T) if (is(T == double))
{
    enum Traits = "abc";
}

auto func(T, A...)(A args) if (is(T == double))
{
    return 1;
}
```

```
module b;

template Traits(T) if (is(T == string))
{
    enum Traits = "def";
}

auto func(T, A...)(A args) if (is(T == string))
{
    return 2;
}
```

```
module c;
import a, b;

// matches to a.Traits
static assert(Traits!double == "abc");
// matches to b.Traits
static assert(Traits!string == "def");

void main()
{
    // matches to a.func(T, A...)
    assert(func!double(1, "msg") == 1);

    // matches to b.func(T, A...)
    assert(func!string(1, "msg") == 2);
}
```

<h3 id="cross-moduletemplate-overload-limitations">Limitations</h3>

Merging template overload sets by using an alias declaration is currently not
supported. The limitation will be lifted in a future release.

<h2 id="compiler-changes">Compiler Changes</h2>

<h3 id="printing-dependencies">Printing Dependencies</h3>

You can now use the **-deps** switch without having to specify a filename. The
dependencies will then be printed to standard output, allowing both users and
tools to introspect the dependencies in the output.

The types of dependencies which are printed out are as follows:

<dl>
<dt>depsImport</dt>
<dd>
Module imports found (same as -deps=file output,
except prefixed with depsImport)
</dd>
<dt>depsVersion</dt>
<dd>Versions (except standard ones and ones set in the module itself)</dd>
<dt>depsFile</dt>
<dd>String imports found, e.g.  <code>string x = import("foo.txt");</code></dd>
<dt>depsLib</dt>
<dd>Libraries specified with a <code>pragma(lib)</code> statement</dd>
<dt>depsDebug</dt>
<dd>
Any <code>debug()</code> statements found (except the ones set in
the module itself)
</dd>
</dl>

<h2 id="compiler-enchancements">Compiler Enhancements</h2>

<h3 id="getunittests-trait">'getUnitTests' Trait</h3>

A new trait, **getUnitTests**, has been introduced. With the new
**getUnitTests** trait you can retrieve all unittest in a module or an
aggregate, and then run the tests manually. Here's an example of implementing a
custom unittest running routine which prints out some additional statistics:

```
import core.runtime;
import core.exception;
import std.stdio;

shared static this()
{
    // this overrides the default D runtime
    // unittest runner function, since we're providing
    // a __traits-based one in our main function.
    Runtime.moduleUnitTester = { return true; };
}

unittest
{
    // passes.
    assert(1);
}

unittest
{
    // fails.
    assert(0);
}

unittest
{
    // passes.
    assert(1);
}

void main()
{
    // collect all thrown exceptions.
    Throwable[] errors;
    // count the number of unittests which pass.
    size_t passCount;

    // iterate over each unittest (this is a tuple).
    foreach (test; __traits(getUnitTests, my_module))
    {
        try
        {
            test();
            passCount++;
        }
        catch (Throwable error)
        {
            errors ~= error;
        }
    }

    // print out the errors or the statistics.
    if (errors.length)
    {
        writeln("Some unittests failed:\n");
        foreach (error; errors)
            writeln(error);
    }
    else
    {
        writefln(
            "All unittests passed. Passed unittest count: %s",
            passCount
        );
    }
}
```

**Note:** You must compile with the **-unittest** flag to be able to retrieve
the unittests.

**Note:** By default the D runtime provides its own unittest execution
function. If you want to avoid it from being invoked at runtime (before the
main function is called) you need to set a custom one by assigning to
**Runtime.moduleUnitTester** in the module constructor.  The one used in the
above test-case simply returns **true**, which allows the **main**
function to be called.

**Note:** The **getUnitTests** trait is not recursive. This means that calling
it on a module will not retrieve unittests which are nested in aggregates in
that module.

<h3 id="getvirtualindex-trait">'getVirtualIndex' Trait</h3>

A **getVirtualIndex** trait has been introduced for getting the index of a
virtual function. You can use this trait to get the index of a virtual method
in the virtual method table:

```
class C
{
    void foo() { }
    void bar() { }
}

class D : C
{
    void doo() { }
    void doo(int) { }
    void doo(double) { }
}

void main()
{
    /**
        Note that each class implicitly inherits from the
        Object class, so the following will most likely not
        begin with index 0.
    */
    pragma(msg, __traits(getVirtualIndex, D.foo));
    pragma(msg, __traits(getVirtualIndex, D.bar));

   /**
       When dealing with overloads you can use the
       getOverloads trait to index into a specific method
   */
   alias dooOverloads = __traits(getOverloads, D, "doo");

   pragma(msg, __traits(getVirtualIndex, dooOverloads[0]));
   pragma(msg, __traits(getVirtualIndex, dooOverloads[1]));
   pragma(msg, __traits(getVirtualIndex, dooOverloads[2]));
}
```

<h3 id="isoverridefunction-trait">'isOverrideFunction' Trait</h3>

The **isOverrideFunction** trait has been introduced which indicates whether or
not a function is overriding:

```
class Base
{
    void foo() { }
}

class Foo : Base
{
    override void foo() { }
    void bar() { }
}

static assert (__traits(isOverrideFunction, Base.foo) == false);
static assert (__traits(isOverrideFunction, Foo.foo)  == true);
static assert (__traits(isOverrideFunction, Foo.bar)  == false);
```

<h2 id="phobos-enhancements">Phobos Enhancements</h2>

<h3 id="structural-typesafe-conversion">Structural Typesafe Conversion</h3>

The structural typesafe conversion functions **wrap** and **unwrap** were
introduced into [std.typecons](/phobos/std_typecons)

Sometimes you may want your class to be usable with a function which expects a
specific interface argument type, but you do not necessarily want to edit the
class to inherit that interface. The class could also be implemented in
another library for which you do not have the source code, which means you
wouldn't be able to edit the inheritance list of that class.

The new **wrap** function allows you to perform a structural cast, allowing a
class object to act as if it were an object of another type. For example (note:
for now please pass the **-allinst** flag to dmd when compiling):

```
import std.typecons;

interface IDrawable
{
    void drawLine(int x1, int y1, int x2, int y2);
}

// note: it does not inherit IDrawable.
class ImageDraw
{
    void drawLine(int x1, int y1, int x2, int y2) { }
}

/** Draw a rectangle outline. */
void drawRect(IDrawable draw)
{
    draw.drawLine(  0,   0, 100,   0);
    draw.drawLine(100,   0, 100, 100);
    draw.drawLine(  0, 100, 100, 100);
    draw.drawLine(  0,   0,   0, 100);
}

void main()
{
    auto imageDraw = new ImageDraw();
    // error: can't call this, ImageDraw is not an IDrawable.
    drawRect(imageDraw);

    // perform a structural cast.
    IDrawable i = wrap!IDrawable(imageDraw);
    // and now imageDraw can act as an IDrawable.
    drawRect(i);
}
```

The **wrap** function can also be used with classes which define an
**opDispatch** function, for example:

```
import std.typecons;

interface IDrawable
{
    void drawLine(int x1, int y1, int x2, int y2);
    void drawRect(int x, int y, int width, int height);
}

class ImageDraw
{
    void opDispatch(string name, Args...)(Args args)
        if (name == "drawLine")
    {
        // ...
    }

    void opDispatch(string name, Args...)(Args args)
        if (name == "drawRect")
    {
        // ...
    }
}

/** Draw some shapes. */
void drawShapes(IDrawable draw)
{
    draw.drawLine(0, 100, 100, 0);
    draw.drawRect(0, 0, 100, 100);
}

void main()
{
    auto imageDraw = new ImageDraw();
    IDrawable i = wrap!IDrawable(imageDraw);
    drawShapes(i);
}
```

You can unwrap a structurally cast object back to its original type:

```
interface IDrawable
{
    void drawLine(int x1, int y1, int x2, int y2);
}

class ImageDraw
{
    void drawLine(int x1, int y1, int x2, int y2) { }
}

void main()
{
    auto imageDraw = new ImageDraw();

    // perform a structural cast (note the simple UFCS syntax).
    IDrawable i = imageDraw.wrap!IDrawable;

    // get back the original type (ditto, using UFCS syntax).
    ImageDraw draw = i.unwrap!ImageDraw;
}
```

And you can structurally cast to multiple interface types:

```
import std.typecons;

unittest
{
    interface IStoppable { void stop(); }
    interface IRunnable { void run(); }

    class Timer
    {
        void run() { }
        void stop() { }
    }

    auto timer = new Timer();
    auto obj = timer.wrap!(IStoppable, IRunnable);

    // extract the individual structurally casted types
    // from the wrapped type
    IStoppable iStop = obj;
    IRunnable  iRun  = obj;

    iRun.run();
    iStop.stop();
}
```

<h3 id="more-pure-functions">More Pure Functions</h3>

**std.conv.to** and **std.string.format** are now pure functions:

```
import std.conv;
import std.string;

// this main is a pure function.
void main() pure
{
    string date = format("%s.%s.%s", 2013, 12, 10);
    int one = to!int(1.0);
}
```

<h3 id="generic-strip-functions">Generic 'strip' Functions</h3>

Generic **strip/stripLeft/stripRight** functions have
been added to [std.algorithm](/phobos/std_algorithm)

The new generic strip functions allow you to not only strip strings but also
any other Input range (**stripLeft**) or Bidirectional range
(**strip/stripRight**), for example:

```
import std.algorithm;

void main()
{
    // strip whitespace.
    assert("  foobar  ".strip!(a => a == ' ')() == "foobar");

    // an audio waveform.
    float[] data = [0.0, 0.0, 0.1, 0.5, 0.2];

    // strip leading silence in the waveform.
    assert(data.strip!(a => a < 0.1)().length == 3);
}
```

<h3 id="buffered-translate">Buffered std.string.translate</h3>

To avoid implicit memory allocations **translate** in
[std.string](/phobos/std_string) now features overloads which can take an
output range to write the contents to. For example:

```
import std.array;
import std.string;

void main()
{
    dchar[dchar] transTable = ['a' : '1', 'b' : '2', 'c': '3'];

    // create our output range by using the Phobos Appender.
    auto buffer = appender!(dchar[])();

    // don't remove any characters.
    auto toRemove = null;

    translate("abcdef", transTable, toRemove, buffer);
    assert(buffer.data == "123def");

    // or use a static array to avoid heap allocations.
    // if the buffer is too small an exception will be thrown.
    dchar[6] dbuffer;
    translate("abcdef", transTable, toRemove, dbuffer[]);
    assert(dbuffer == "123def");
}
```

<h3 id="thisexepath-function">thisExePath function</h3>

The **thisExePath** function has been introduced for retrieving the executable
path of the currently running process:

```
import std.file;
import std.stdio;

void main(string[] args)
{
    // Prints the full path of the current running executable.
    // Note: this may, or may not be the same as args[0].
    // The content of args[0] is dependent of how
    // the application was invoked, thisExePath() is not.
    // It's also possible to access thisExePath()
    // from other parts of the code than main.
    writeln(thisExePath());
}
```

<h3 id="new-regex-api">New regex match/replace API</h3>

The api for **match** and **replace** in [std.regex](/phobos/std_regex) has
been changed.

The old API based around **"g"(=global)** flag was confusing and error prone.
Moreover in some cases it was already being overriden by a function as is the
case with **std.regex.splitter**.

The new version ties the operation to the function in question, thus being
simpler to understand without extra context.  For the moment the "g" flag is
kept working as is but the new API always overrides it where applicable.
Another addition in the new API is an overload for the **replace** family of
functions to work directly with output ranges.

To understand the difference in the API compare 2 samples below.

Before 2.064:

```
void main()
{
    import std.regex;
    import std.algorithm:
    import std.range;
    import std.stdio;
    import std.string;

    auto m = "3.141592".match(`(\d+)\.(\d+)`);
    // m is a range of ranges
    assert(m.front.equal(["3.141592", "3", "141592"]));

    // global vs non-global
    auto word = regex(`(\w)\w*`);
    auto gword = regex(`(\w)\w*`, "g");
    auto list = "tomatoes, potatoes, pineapple";
    // this will print only 'tomatoes',
    // which raised many questions
    foreach(item; list.match(word))
        writeln(item.hit);

    // while this will print each of them
    foreach(item; list.match(gword))
        writeln(item.hit);

    auto justFirst = replace!(
        m => toUpper(m[1]) ~ m[0].drop(1)
    )(list, word);

    assert(justFirst == "Tomatoes, potatoes, pineapple");

    auto allOfThem = replace!(
        m => toUpper(m[1]) ~ m[0].drop(1)
    )(list, gword);

    assert(allOfThem == "Tomatoes, Potatoes, Pineapple");
}
```

After 2.064:

```
void main()
{
    import std.regex;
    import std.algorithm:
    import std.range;
    import std.stdio;
    import std.string;
    auto m = "3.141592".matchFirst(`(\d+)\.(\d+)`);
    // m is simply a range of submatches
    assert(m.equal(["3.141592", "3", "141592"]));

    auto word = regex(`(\w)\w*`);
    auto list = "tomatoes, potatoes, pineapple";
    // iterates over submatches so it will print 2 lines:
    // tomatoes
    // t
    foreach(item; list.matchFirst(word))
        writeln(item);
    // so just to get the whole match:
    assert(list.matchFirst(word).hit == "tomatoes");

    // now there is no need to check if it has "g" option
    // it's crystal clear in the function name
    foreach(item; list.matchAll(word))
        writeln(item.hit);

    auto justFirst = replaceFirst!(
        m => toUpper(m[1]) ~ m[0].drop(1)
    )(list, word);

    assert(justFirst == "Tomatoes, potatoes, pineapple");

    auto allOfThem = replaceAll!(
        m => toUpper(m[1]) ~ m[0].drop(1)
    )(list, word);

    assert(allOfThem == "Tomatoes, Potatoes, Pineapple");

    // NEW feature - if there is no need to allocate,
    // the resulting string
    // replacement may be just sent directly to
    // the wire (an OutputRange)
    auto sink = stdout.lockingTextWriter();
    replaceAllInto!(
        m => toUpper(m[1]) ~ m[0].drop(1)
    )(sink, list, word);
}
```

The old API still works, even though eventual deprecation is planned. Also note
the new functionality in form of *Into functions that forward the replacement
directly to an output range avoiding extra pressure on the heap.

<h3 id="ctregex-lookahead">ctRegex Lookahead</h3>

Compile-time **ctRegex** from [std.regex](/phobos/std_regex) now supports
lookaround just like run-time one:

Now **ctRegex** supports full syntax spectrum of run-time one except for set
algebra inside of a character class.  For instance, the following now compiles
and passes:

```
void main()
{
    import std.regex;
    // a word, but not a title-cased ASCII
    // ?&lt;! inside of () means "negative lookbehind"
    auto pat = ctRegex!`\w+(?&lt;![A-Z][a-z]*)`;
    assert(!"Hello".match(pat));
    assert("good_bay".match(pat));
}
```

<h2 id="dmd-compiler-regressions">DMD Compiler Regressions Fixed</h2>

* [Bugzilla 6014](/bug/6014) &mdash; rt_finalize Segmentation fault , dmd 2.053 on linux & freebsd
* [Bugzilla 10074](/bug/10074) &mdash; segfault in dmd
* [Bugzilla 10197](/bug/10197) &mdash; [REG2.063] Cannot cast overloaded template property result
* [Bugzilla 10212](/bug/10212) &mdash; Segfault in mismatching delegate literal types
* [Bugzilla 10215](/bug/10215) &mdash; Regression (2.063 release): const causes wrong float calculation
* [Bugzilla 10220](/bug/10220) &mdash; `array` doesn't work with disabled default construction
* [Bugzilla 10255](/bug/10255) &mdash; When creating lib files, dmd no longer splits module into multiple obj files
* [Bugzilla 10299](/bug/10299) &mdash; [REG2.063] ICE with getting address of template
* [Bugzilla 10330](/bug/10330) &mdash; Regresfsion (2.063.2): __VERSION__ is set wrong
* [Bugzilla 10337](/bug/10337) &mdash; Error: mutable method glwtf.input.SignalWrapper!().SignalWrapper.Signal!().~this
* [Bugzilla 10352](/bug/10352) &mdash; Regression (2.063): --eval is broken in RDMD
* [Bugzilla 10357](/bug/10357) &mdash; std.typecons.Nullable!(SysTime).Nullable.__ctor!() error instantiating
* [Bugzilla 10373](/bug/10373) &mdash; cannot resolve forward reference (dmd2.063)
* [Bugzilla 10375](/bug/10375) &mdash; [REG2.061] private template from imported module hijacks a template type parameter(!)
* [Bugzilla 10382](/bug/10382) &mdash; Regression (2.059): ICE when catching illegal type
* [Bugzilla 10394](/bug/10394) &mdash; opBinaryRight!"in" and tuple
* [Bugzilla 10397](/bug/10397) &mdash; ICE on concatenating string with unexisted symbol
* [Bugzilla 10425](/bug/10425) &mdash; Link error with templates
* [Bugzilla 10440](/bug/10440) &mdash; shared library on osx: worked in 2.062, fails in 2.063 / 2.063.2
* [Bugzilla 10441](/bug/10441) &mdash; Static libraries too big
* [Bugzilla 10456](/bug/10456) &mdash; struct containing enum X, alias X this and a dynamic array no longer compiles since 2.063
* [Bugzilla 10481](/bug/10481) &mdash; out of memory error
* [Bugzilla 10486](/bug/10486) &mdash; Segfault on assigning `typeof(null)` to static array
* [Bugzilla 10498](/bug/10498) &mdash; `__traits(compiles, ...)` affect program behaviour
* [Bugzilla 10503](/bug/10503) &mdash; Octal enums don't work anymore
* [Bugzilla 10505](/bug/10505) &mdash; anonymous enum members cannot have different types
* [Bugzilla 10537](/bug/10537) &mdash; Forward reference error on 'yield' toy example.
* [Bugzilla 10548](/bug/10548) &mdash; [REG 2.064a] argument has no identifier
* [Bugzilla 10558](/bug/10558) &mdash; Assertion failure on struct.c:741
* [Bugzilla 10561](/bug/10561) &mdash; Regression (2.064 HEAD): anon enum members no longer have enum base type
* [Bugzilla 10573](/bug/10573) &mdash; Weird linking problem with associative array cast [DMD 2.63]
* [Bugzilla 10577](/bug/10577) &mdash; 2.063 Mixin Regression (works with 2.062)
* [Bugzilla 10579](/bug/10579) &mdash; regression 062=>063: Cannot interpret TypeInfo at compile time
* [Bugzilla 10592](/bug/10592) &mdash; Regression of overloaded template function
* [Bugzilla 10600](/bug/10600) &mdash; regression(2.063.2) ICE: Assertion failed: (type->ty != Tstruct || ((TypeStruct *)type)->sym == this), function semantic, file struct.c, line 741.
* [Bugzilla 10612](/bug/10612) &mdash; Regression (2.064 HEAD): ICE on using enum as hash key with mutual module imports
* [Bugzilla 10617](/bug/10617) &mdash; contract with -profile -debug is not nothrow
* [Bugzilla 10624](/bug/10624) &mdash; [REG2.064a] ICE with tuple comparison
* [Bugzilla 10626](/bug/10626) &mdash; ICE with vector operation
* [Bugzilla 10628](/bug/10628) &mdash; [REG2.063] spurious "hidden by" deprecation warning
* [Bugzilla 10669](/bug/10669) &mdash; CTFE: using initialized static const class member no longer works
* [Bugzilla 10673](/bug/10673) &mdash; memory corruption in interpret.c
* [Bugzilla 10682](/bug/10682) &mdash; [ICE](cgcod.c line 1561) with ^^ operator and ulong
* [Bugzilla 10684](/bug/10684) &mdash; Refused array op with array literal
* [Bugzilla 10687](/bug/10687) &mdash; Refused cast from uint[] to array of uint-based enums at compile-time
* [Bugzilla 10713](/bug/10713) &mdash; [REG2.063] ICE with typeof(this.nonExistingField) in method signature
* [Bugzilla 10721](/bug/10721) &mdash; ICE with constructor with postcondition
* [Bugzilla 10722](/bug/10722) &mdash; Regression (2.064 git-head): Cannot interpret struct at compile-time
* [Bugzilla 10726](/bug/10726) &mdash; Bogus Circular Reference error if opEquals defined and has a loop
* [Bugzilla 10727](/bug/10727) &mdash; Regression (dmd-2.061) -- DMD dumps core
* [Bugzilla 10734](/bug/10734) &mdash; Assertion failure: '0' on line 1546 in file 'cast.c'
* [Bugzilla 10736](/bug/10736) &mdash; Regression (2.064 git-head): Instantiation failure triggered by module import and module order
* [Bugzilla 10744](/bug/10744) &mdash; [regression git-head v2.064] Rejects valid interface inheritance + wrong error message
* [Bugzilla 10782](/bug/10782) &mdash; dmd segfault with string mixin, CTFE, class, non-literal initializer
* [Bugzilla 10788](/bug/10788) &mdash; Regression: forward reference of enum member E from another module.
* [Bugzilla 10789](/bug/10789) &mdash; Struct destructor erroneously called
* [Bugzilla 10804](/bug/10804) &mdash; regression(2.063=>2.064) problem with Appender or dmd?
* [Bugzilla 10808](/bug/10808) &mdash; [REG2.064a] Incorrect typeid template argument should report error
* [Bugzilla 10836](/bug/10836) &mdash; 'errors compiling the function' for optimized builds
* [Bugzilla 10946](/bug/10946) &mdash; Integer constant expression expected instead of...
* [Bugzilla 10949](/bug/10949) &mdash; CTFE ICE after indexing error
* [Bugzilla 10964](/bug/10964) &mdash; [REG][2.063] Static array assign/blit exception slips through catch block.
* [Bugzilla 10981](/bug/10981) &mdash; Contracts in pure class methods are useless
* [Bugzilla 10994](/bug/10994) &mdash; [REG] cannot declare statics struct with void-initialized static arrays
* [Bugzilla 10998](/bug/10998) &mdash; [REG 2.063] compile-time postblit call check is incorrectly suppressed.
* [Bugzilla 11010](/bug/11010) &mdash; Regression (2.063.2) typeid doesn't work on a member of an instance.
* [Bugzilla 11039](/bug/11039) &mdash; Undefined instantiation from circular imports
* [Bugzilla 11054](/bug/11054) &mdash; ICE: interpret.c:357: virtual void Statement::ctfeCompile(CompiledCtfeFunction*): Assertion `0' failed.
* [Bugzilla 11062](/bug/11062) &mdash; inline ice with alias this and opIndexAssign
* [Bugzilla 11069](/bug/11069) &mdash; DMD (github HEAD) Linker Regression
* [Bugzilla 11081](/bug/11081) &mdash; Win64: duplicate COMDAT with failed compilation with lambdas
* [Bugzilla 11086](/bug/11086) &mdash; dmd segfault
* [Bugzilla 11105](/bug/11105) &mdash; Error on struct with multidimentional static array initialization from its element
* [Bugzilla 11117](/bug/11117) &mdash; Pseudo module __entrypoint.d listed as dependency with -deps
* [Bugzilla 11121](/bug/11121) &mdash; Wrong parenthesis omission in ddoc output
* [Bugzilla 11127](/bug/11127) &mdash; std.range.cycle linker errors
* [Bugzilla 11153](/bug/11153) &mdash; Regression (2.064 git-head): ICE during a diagnostic for missing return type
* [Bugzilla 11163](/bug/11163) &mdash; [ICE](ctfeexpr.c line 355) with pragma(msg) of a wrong expression
* [Bugzilla 11186](/bug/11186) &mdash; Regression (2.061): Presence of Variant and const field invokes opAssign
* [Bugzilla 11197](/bug/11197) &mdash; [DMD 2.064a] Struct with postblit cannot be appended to an AA of arrays
* [Bugzilla 11203](/bug/11203) &mdash; extern (C++) classes broken
* [Bugzilla 11220](/bug/11220) &mdash; Regression in master: XXX__lambda2 cannot access frame of function XXX
* [Bugzilla 11223](/bug/11223) &mdash; inline ice with tuple assignment and if/else
* [Bugzilla 11225](/bug/11225) &mdash; Module dependency cycle causes import statements inside typeof() expressions inside templates to fail
* [Bugzilla 11228](/bug/11228) &mdash; alias this confuses static array copy
* [Bugzilla 11230](/bug/11230) &mdash; [REG2.064a] Inexact mangling for template function literal.
* [Bugzilla 11233](/bug/11233) &mdash; DMD HEAD very slow with large static array struct field
* [Bugzilla 11237](/bug/11237) &mdash; zero initializer emitted to read-only data segment, slow compilation
* [Bugzilla 11242](/bug/11242) &mdash; [REG2.064beta] Fails to infer template argument with inout
* [Bugzilla 11245](/bug/11245) &mdash; [REG 2.063] Can't access length of static arrays from within classes
* [Bugzilla 11246](/bug/11246) &mdash; [REG 2.063] Struct initialized in constructor is destroyed first
* [Bugzilla 11256](/bug/11256) &mdash; Error mixing struct with disabled default construction and templated with lambda struct
* [Bugzilla 11261](/bug/11261) &mdash; Can't infer types without explicit slice in foreach
* [Bugzilla 11262](/bug/11262) &mdash; std.regex.replace does not accept StaticRegex
* [Bugzilla 11265](/bug/11265) &mdash; Segfault while calling instance method of class defined inside struct
* [Bugzilla 11267](/bug/11267) &mdash; Resulting executable sizes varies a lot
* [Bugzilla 11271](/bug/11271) &mdash; [REG 2.063] auto ref opAssign + destructor + struct literal fails

<h2 id="dmd-compiler-bugs">DMD Compiler Bugs Fixed</h2>

* [Bugzilla 952](/bug/952) &mdash; Strange "Error:" prefix on some warning messages
* [Bugzilla 1982](/bug/1982) &mdash; [CTFE] Problems with compile-time null
* [Bugzilla 2407](/bug/2407) &mdash; function pointer as an enum's base type doesn't work
* [Bugzilla 2486](/bug/2486) &mdash; taking address of slice rvalue should not be allowed
* [Bugzilla 3096](/bug/3096) &mdash; EnumBaseType
* [Bugzilla 3646](/bug/3646) &mdash; Default values of function arguments are ignored when instantiating a template.
* [Bugzilla 3866](/bug/3866) &mdash; anonymous delegate with default parameters cross-talks to another anonymous delegate
* [Bugzilla 4018](/bug/4018) &mdash; __FILE__ and __LINE__ as default template parameters not set to instantiation point per spec
* [Bugzilla 4481](/bug/4481) &mdash; ICE(glue.c,!vthis->csym) or compiles, depending on the import statements order
* [Bugzilla 4611](/bug/4611) &mdash; stack overflow or ICE(cgcod.c) when static array of structs exceeds 16MB limit
* [Bugzilla 4841](/bug/4841) &mdash; -inline wrecks certain nested structs causing error "*** is a nested function and cannot be accessed from ***"
* [Bugzilla 4899](/bug/4899) &mdash; Ddoc: Warnings about stray parens do not include file and line numbers for module comments
* [Bugzilla 5012](/bug/5012) &mdash; ICE(cod3.c): handling a nested function in inline asm.
* [Bugzilla 5655](/bug/5655) &mdash; Lambda inside static foreach saves wrong value of counter
* [Bugzilla 5842](/bug/5842) &mdash; hash table corruption
* [Bugzilla 5911](/bug/5911) &mdash; Closure destroys the thrown Exception .
* [Bugzilla 5988](/bug/5988) &mdash; Template accepts instantiating an already-instantiated template type
* [Bugzilla 6107](/bug/6107) &mdash; ICE(expression.c) when a non-template member named '__ctor' exists in a struct, and the constructor is attempted to be invoked.
* [Bugzilla 6169](/bug/6169) &mdash; [CTFE] pure functions cannot compute constants using functions not marked as pure
* [Bugzilla 6178](/bug/6178) &mdash; Struct inside the AA are not init correctly
* [Bugzilla 6310](/bug/6310) &mdash; Missing "template instantiation" traceback when an error happens in the template parameter of an alias.
* [Bugzilla 6461](/bug/6461) &mdash; multiple definitions with typeid and multiobj
* [Bugzilla 6711](/bug/6711) &mdash; "with" doesn't work with "alias this"
* [Bugzilla 6720](/bug/6720) &mdash; ICE(cod1.c) casting return of void function to bool
* [Bugzilla 6799](/bug/6799) &mdash; ICE(type.c) involving AAs and pointers to structs
* [Bugzilla 6906](/bug/6906) &mdash; Cannot assign value into associative array if contains opAssign
* [Bugzilla 7051](/bug/7051) &mdash; Class member with un-@safe destructor gives confusing error
* [Bugzilla 7156](/bug/7156) &mdash; ICE(go.c): with 199 or 200 repeated integer increments, only with -O
* [Bugzilla 7202](/bug/7202) &mdash; Hole in type system still present for delegates
* [Bugzilla 7254](/bug/7254) &mdash; ICE(cod3.c) returning strings as static arrays
* [Bugzilla 7436](/bug/7436) &mdash; ICE(cg87.c) ubyte = ubyte op= float
* [Bugzilla 7474](/bug/7474) &mdash; ICE(cgcs.c) on instantiating a struct with field and destructor as tuple
* [Bugzilla 7522](/bug/7522) &mdash; ICE(interpret.c) Accessing a non-static member without this
* [Bugzilla 7524](/bug/7524) &mdash; D1: #line __LINE__ doesn't parse
* [Bugzilla 7533](/bug/7533) &mdash; Error with no line number with pure static ctor
* [Bugzilla 7538](/bug/7538) &mdash; All kinds of property functions should be called before getting their types inside typeof
* [Bugzilla 7565](/bug/7565) &mdash; ICE(cg87):202, postincrement of a double parameter, 64-bit only
* [Bugzilla 7656](/bug/7656) &mdash; ddoc misinterprets commented parentheses in an example
* [Bugzilla 7715](/bug/7715) &mdash; DDoc eats , , etc. inside d_code section
* [Bugzilla 7727](/bug/7727) &mdash; "static initializer" for non-static unions too
* [Bugzilla 7746](/bug/7746) &mdash; Error with 'TOK232' declaring enum of anonymous nested class type
* [Bugzilla 7780](/bug/7780) &mdash; Template mixin'd members do not properly overload
* [Bugzilla 7806](/bug/7806) &mdash; ICE(gloop.c) iterating with idouble, when compiling with -O
* [Bugzilla 7848](/bug/7848) &mdash; pure and nothrow ignored on unittest blocks
* [Bugzilla 7892](/bug/7892) &mdash; Compiler-generated struct copies can result in errors when ctor is @disable'd
* [Bugzilla 7976](/bug/7976) &mdash; ICE(backend/cg87.c)assignment btw two elements of dynamic array of complex number types
* [Bugzilla 7988](/bug/7988) &mdash; [CTFE] CTFE return values should be allowed in compile-time expressions
* [Bugzilla 8119](/bug/8119) &mdash; Cannot cast from void* to forwarded struct pointer
* [Bugzilla 8179](/bug/8179) &mdash; ICE(e2ir.c) with failed fixed size array cast
* [Bugzilla 8253](/bug/8253) &mdash; CTFE ICE: calling of member function of non-CTFE class variable
* [Bugzilla 8285](/bug/8285) &mdash; Issue with slice returned from CTFE function
* [Bugzilla 8352](/bug/8352) &mdash; Wrong "__overloadset isn't a template" error
* [Bugzilla 8360](/bug/8360) &mdash; Destruction of uninitialized temporary struct with assert
* [Bugzilla 8361](/bug/8361) &mdash; [ICE] (eh.c line 316) with struct with dtor in assert
* [Bugzilla 8441](/bug/8441) &mdash; mixin containing template functions causes compiler errors
* [Bugzilla 8563](/bug/8563) &mdash; Exception segfault
* [Bugzilla 8579](/bug/8579) &mdash; Default parameter appears a part of typeof().stringof of a function variable
* [Bugzilla 8651](/bug/8651) &mdash; Slice op Slice throws exceptions (not errors), and nothrow
* [Bugzilla 8733](/bug/8733) &mdash; Normalize -of path on Windows
* [Bugzilla 8795](/bug/8795) &mdash; mixing in "switch" or "interface;" makes dmd segfault
* [Bugzilla 8911](/bug/8911) &mdash; -property makes fullyQualifiedName fail for functions
* [Bugzilla 8956](/bug/8956) &mdash; Ability to break typesystem with constructor/postblit/destructor (e.g. modify immutable)
* [Bugzilla 8977](/bug/8977) &mdash; Ability to break typesystem with static struct initializer (e.g. modify immutable)
* [Bugzilla 9017](/bug/9017) &mdash; __traits(compiles, { enum e = ; }) is true but code doesn't compile
* [Bugzilla 9235](/bug/9235) &mdash; Template mixin doesn't allow to mixin non-conflicting overloads
* [Bugzilla 9247](/bug/9247) &mdash; Compiler accepts opaque struct returned by value from function pointer declaration.
* [Bugzilla 9319](/bug/9319) &mdash; Unexpected compiles __traits behaviour in a certain situation
* [Bugzilla 9364](/bug/9364) &mdash; [ICE] Error: CTFE internal error painting S*
* [Bugzilla 9396](/bug/9396) &mdash; Wrong line number when assigning nested enum to struct
* [Bugzilla 9524](/bug/9524) &mdash; Unittest ddocs fail to appear following ditto
* [Bugzilla 9531](/bug/9531) &mdash; __traits(parent, ...) does not work for types defined within a unittest block
* [Bugzilla 9534](/bug/9534) &mdash; Distributed CHM file lacks styling
* [Bugzilla 9546](/bug/9546) &mdash; getProtection trait does not work with mixin or getMember
* [Bugzilla 9571](/bug/9571) &mdash; link error due to using unique ids in anonymous funcliteral
* [Bugzilla 9578](/bug/9578) &mdash; "is a nested function and cannot be accessed from" problem
* [Bugzilla 9586](/bug/9586) &mdash; Win64 5/6/7 struct returns
* [Bugzilla 9628](/bug/9628) &mdash; Lambda in foreach loop Vs. lambda in static foreach loop
* [Bugzilla 9634](/bug/9634) &mdash; [CTFE] wrong code concatenating arrays of structs
* [Bugzilla 9665](/bug/9665) &mdash; Structure constant members can not be initialized if have opAssign
* [Bugzilla 9710](/bug/9710) &mdash; Pointer enums crash dmd
* [Bugzilla 9733](/bug/9733) &mdash; Hello world segfaults on Debian x86_64 with -m64
* [Bugzilla 9782](/bug/9782) &mdash; implementing RTInfo!T causes errors for deprecated types
* [Bugzilla 9859](/bug/9859) &mdash; Cannot use inout in delegate
* [Bugzilla 9904](/bug/9904) &mdash; typeof(null) can be casted to aggregate type if .sizeof equals size of pointer
* [Bugzilla 9921](/bug/9921) &mdash; Enum variables of type void should be illegal
* [Bugzilla 9923](/bug/9923) &mdash; [ICE] (interpret.c line 167) with countUntil on Typedef[]
* [Bugzilla 9938](/bug/9938) &mdash; ICE using global interface variable in CTFE
* [Bugzilla 9954](/bug/9954) &mdash; Runtime wrong code with global interface var created in CTFE
* [Bugzilla 9982](/bug/9982) &mdash; ICE on CTFE for pointer dereference
* [Bugzilla 10007](/bug/10007) &mdash; function overrides but is not covariant
* [Bugzilla 10037](/bug/10037) &mdash; Compiler should not generate opEquals method implicitly
* [Bugzilla 10064](/bug/10064) &mdash; opDollar called on garbage
* [Bugzilla 10065](/bug/10065) &mdash; Compiler fails without error message for tuple map
* [Bugzilla 10079](/bug/10079) &mdash; Built-in generated opAssign should be pure nothrow @safe by default
* [Bugzilla 10082](/bug/10082) &mdash; ICE(e2ir.c) Multiple mixin template instantiations are not checked
* [Bugzilla 10083](/bug/10083) &mdash; Insufficient IFTI/eponymous template specification
* [Bugzilla 10086](/bug/10086) &mdash; ICE(glue.c) or wrong code on passing variable as template value parameter
* [Bugzilla 10094](/bug/10094) &mdash; NRVO with static array return should work
* [Bugzilla 10099](/bug/10099) &mdash; Diagnostic for disabled default construction should improve
* [Bugzilla 10113](/bug/10113) &mdash; Can't use an enum : string in a switch statement
* [Bugzilla 10141](/bug/10141) &mdash; wrong error message with Tuple!(int) : Error: static assert "Cannot put a char[] into a Appender!(string)"
* [Bugzilla 10156](/bug/10156) &mdash; Can't handle usage of TypeTuple argument in templated function
* [Bugzilla 10196](/bug/10196) &mdash; RDMD: RDMD can't be used from MSys
* [Bugzilla 10198](/bug/10198) &mdash; CTFE: Wrong code for multi-dimensional block assignment
* [Bugzilla 10208](/bug/10208) &mdash; Module-level const/immutable variables with initialization value don't support UDAs
* [Bugzilla 10211](/bug/10211) &mdash; CTFE: Support casts from S** to D**, if S* -> D* is supported.
* [Bugzilla 10214](/bug/10214) &mdash; Incorrect "element-wise assignment is better" warning
* [Bugzilla 10243](/bug/10243) &mdash; [CTFE] Wrong-code on passing dereferenced array pointer by ref
* [Bugzilla 10244](/bug/10244) &mdash; ICE: expression.c:8364: virtual Expression* CallExp::semantic(Scope*): Assertion `td' failed
* [Bugzilla 10249](/bug/10249) &mdash; incorrect mangling for overloaded symbol
* [Bugzilla 10252](/bug/10252) &mdash; CTFE: Should generate error for shifts outside valid range
* [Bugzilla 10254](/bug/10254) &mdash; Purity correctness is broken with constructor
* [Bugzilla 10273](/bug/10273) &mdash; ICE(ctfeexpr.c): using CTFE after error in struct default values
* [Bugzilla 10274](/bug/10274) &mdash; DMD 2.063 produces broken binaries
* [Bugzilla 10275](/bug/10275) &mdash; CTFE: Allow const casts of struct literals
* [Bugzilla 10277](/bug/10277) &mdash; Incorrect error file and line on redeclaration of TypeInfo
* [Bugzilla 10279](/bug/10279) &mdash; Calling a typesafe variadic @trusted function from an @safe function results in an error.
* [Bugzilla 10280](/bug/10280) &mdash; CTFE: Circular variable initializers should be detected properly
* [Bugzilla 10283](/bug/10283) &mdash; ICE(interpret.c): passing struct with failed initalizer to CTFE
* [Bugzilla 10288](/bug/10288) &mdash; Direct lambda call and purity inference bug
* [Bugzilla 10289](/bug/10289) &mdash; compiler should infer nothrow even if Error is thrown
* [Bugzilla 10296](/bug/10296) &mdash; Nested template function call and purity inference bug
* [Bugzilla 10298](/bug/10298) &mdash; CTFE fails with array literal initialization
* [Bugzilla 10302](/bug/10302) &mdash; Package module conflicts with package name
* [Bugzilla 10319](/bug/10319) &mdash; @safe/pure/nothrow error should print fully qualified name
* [Bugzilla 10325](/bug/10325) &mdash; ddoc: template constraints inconsistently shown in generated html
* [Bugzilla 10327](/bug/10327) &mdash; Missing 'package.d' for DIP37 needs a better error message
* [Bugzilla 10341](/bug/10341) &mdash; Range case without an associated switch statement crashes DMD
* [Bugzilla 10343](/bug/10343) &mdash; Cannot resolve a forward reference to a template inside global typeof
* [Bugzilla 10344](/bug/10344) &mdash; Exiting _Dmain should flush all FILE*s and return nonzero on failure
* [Bugzilla 10346](/bug/10346) &mdash; No line number error with undefined template identifier
* [Bugzilla 10354](/bug/10354) &mdash; DIP37: ICE with using indirectly imported template through package.d
* [Bugzilla 10359](/bug/10359) &mdash; Pointer slicing allowed in @safe mode
* [Bugzilla 10381](/bug/10381) &mdash; Nonsense associative array comparison
* [Bugzilla 10386](/bug/10386) &mdash; Package import feature breaks with static libraries
* [Bugzilla 10389](/bug/10389) &mdash; Infinite recursion on printing self-referential StructLiteralExp
* [Bugzilla 10390](/bug/10390) &mdash; ICE on printing ClassReferenceExp
* [Bugzilla 10405](/bug/10405) &mdash; redundant "expression has no effect" error when returning non-void in void function
* [Bugzilla 10414](/bug/10414) &mdash; Delegate arguments for lazy variadic functions are only inferred in first argument
* [Bugzilla 10415](/bug/10415) &mdash; Bad error message with const property of const class instance
* [Bugzilla 10418](/bug/10418) &mdash; bad error message: "not a property"
* [Bugzilla 10419](/bug/10419) &mdash; Unhandled exception in dmd after correct error message
* [Bugzilla 10421](/bug/10421) &mdash; 'package' access should work with package module
* [Bugzilla 10429](/bug/10429) &mdash; RDMD: --loop option doesn't work due to symbol conflict
* [Bugzilla 10431](/bug/10431) &mdash; ICE(DMD 2.063) in struct.c:741
* [Bugzilla 10432](/bug/10432) &mdash; RDMD: --dry-run option tries to read non-existent file
* [Bugzilla 10433](/bug/10433) &mdash; Array sum operation in function template
* [Bugzilla 10435](/bug/10435) &mdash; rdmd doesn't support the -op argument.
* [Bugzilla 10451](/bug/10451) &mdash; Array of pointers to opaque struct gives forward reference errors.
* [Bugzilla 10452](/bug/10452) &mdash; CTFE: Cannot compare delegates with == or 'is'
* [Bugzilla 10462](/bug/10462) &mdash; interface thunk doesn't preserve EBX
* [Bugzilla 10479](/bug/10479) &mdash; cannot pass implicitly to base class casted result to out contract by ref
* [Bugzilla 10495](/bug/10495) &mdash; Incorrect "initializer required" error using lambdas in class with fields with disabled default construction
* [Bugzilla 10497](/bug/10497) &mdash; Opaque structs cannot be dereferenced in pointer to pointer types
* [Bugzilla 10504](/bug/10504) &mdash; Tuple error: no property 'offsetof' for type 'int'
* [Bugzilla 10506](/bug/10506) &mdash; Purity should not be checked in a mixin statement
* [Bugzilla 10519](/bug/10519) &mdash; Stray-paren in doc-unittest code generates wrong document
* [Bugzilla 10526](/bug/10526) &mdash; opDispatch with IFTI should not disable UFCS
* [Bugzilla 10534](/bug/10534) &mdash; Addition and subtraction of delegates allowed
* [Bugzilla 10539](/bug/10539) &mdash; [REG][2.063] Implicit pointer to array dereference for .ptr property fails
* [Bugzilla 10542](/bug/10542) &mdash; implicitly generated class ctor doesnt inherit base class ctor attributes
* [Bugzilla 10551](/bug/10551) &mdash; [CTFE] Wrong-code on passing dereferenced array pointer by ref 2
* [Bugzilla 10568](/bug/10568) &mdash; CTFE rejects function pointer safety casts
* [Bugzilla 10583](/bug/10583) &mdash; DMD 2.063 dumps core with mixins involving __traits(getProtection, ..
* [Bugzilla 10595](/bug/10595) &mdash; Using alias this and a hash generates wrong code
* [Bugzilla 10596](/bug/10596) &mdash; A method with out contract and auto return type causes segfault
* [Bugzilla 10597](/bug/10597) &mdash; opDollar not callable in static constext
* [Bugzilla 10599](/bug/10599) &mdash; CTFE: assert failure interpret.c 310
* [Bugzilla 10609](/bug/10609) &mdash; Refused UFCS in __traits(compile)
* [Bugzilla 10610](/bug/10610) &mdash; interpret.c:4067 Assertion Failure
* [Bugzilla 10618](/bug/10618) &mdash; Template instance member access disallowed in dynamic array allocation
* [Bugzilla 10630](/bug/10630) &mdash; Structs with disabled default construction can't be used as `out` parameters
* [Bugzilla 10633](/bug/10633) &mdash; Win64: wrong codegen with %=
* [Bugzilla 10634](/bug/10634) &mdash; Win64: wrong codegen with .init of small structs
* [Bugzilla 10639](/bug/10639) &mdash; Win64: wrong optimizer codegen with struct literal with complex fields
* [Bugzilla 10642](/bug/10642) &mdash; Win64: wrong codegen comparing different sized integer arguments
* [Bugzilla 10646](/bug/10646) &mdash; No front-end error for invalid casting dynamic array/static array to class reference
* [Bugzilla 10651](/bug/10651) &mdash; Throwing non-Throwable object causes ICE
* [Bugzilla 10676](/bug/10676) &mdash; excessive compilation times with optimized PIC build
* [Bugzilla 10677](/bug/10677) &mdash; Win64: cfloat return value not forwarded correctly as function argument
* [Bugzilla 10678](/bug/10678) &mdash; Win64: wrong code passing small fixed sized array as function argument
* [Bugzilla 10694](/bug/10694) &mdash; wrong purity check for static variables with impure destructor
* [Bugzilla 10695](/bug/10695) &mdash; __MODULE__ in string mixin crashes compiler
* [Bugzilla 10715](/bug/10715) &mdash; negated bit test (bt) not recognized by optimizer
* [Bugzilla 10735](/bug/10735) &mdash; Buffer overflow bug in symbol_generate()
* [Bugzilla 10746](/bug/10746) &mdash; Win64: corrupt debug info with very long symbols
* [Bugzilla 10752](/bug/10752) &mdash; accessing a private cached symbol a second time doesn't cause an error in __traits(compiles, ...)
* [Bugzilla 10758](/bug/10758) &mdash; Unsound type checking for inout.
* [Bugzilla 10761](/bug/10761) &mdash; DMD crashes on unspecified inout matching.
* [Bugzilla 10768](/bug/10768) &mdash; DMD does not show deprecation message for missing 'override' keyword
* [Bugzilla 10781](/bug/10781) &mdash; ctRegex! throws a huge error
* [Bugzilla 10783](/bug/10783) &mdash; ICE and bad diagnostics when using non-existent symbols in switch and with statements
* [Bugzilla 10792](/bug/10792) &mdash; Bad diagnostic on new eponymous enum template syntax
* [Bugzilla 10793](/bug/10793) &mdash; Forward reference errors casting from void* to opaque struct pointer
* [Bugzilla 10809](/bug/10809) &mdash; [REG] darwin 32 dmd release broken
* [Bugzilla 10811](/bug/10811) &mdash; Order dependent IFTI failure
* [Bugzilla 10813](/bug/10813) &mdash; ICE(DMD2.063) template.c:6040: Identifier* TemplateInstance::genIdent(Objects*): Assertion `global.errors' failed
* [Bugzilla 10834](/bug/10834) &mdash; cannot use cast(void)expr if the type of expr is a struct
* [Bugzilla 10840](/bug/10840) &mdash; [CTFE] *this._data.arr is not yet implemented at compile time
* [Bugzilla 10842](/bug/10842) &mdash; Some integer casts wrongly remove side-effect of the operand.
* [Bugzilla 10857](/bug/10857) &mdash; ICE(glue.c,bugzilla 2962?) or compiles, depending on the files order
* [Bugzilla 10858](/bug/10858) &mdash; CTFE wrong code for comparison of array of pointers
* [Bugzilla 10862](/bug/10862) &mdash; Assignment inside if condition still sometimes accepted
* [Bugzilla 10869](/bug/10869) &mdash; Ddoc mark methods with "const" twice
* [Bugzilla 10870](/bug/10870) &mdash; Ddoc adds "abstract" to interfaces
* [Bugzilla 10937](/bug/10937) &mdash; struct inside union gives uninitialized error in CTFE
* [Bugzilla 10942](/bug/10942) &mdash; ICE on 1087+ initializers (Internal error: backend\cgcv.c 203)
* [Bugzilla 10944](/bug/10944) &mdash; [ICE](interpret.c line 310) with arith operation on missing variable
* [Bugzilla 10947](/bug/10947) &mdash; const out parameter is not properly rejected
* [Bugzilla 10953](/bug/10953) &mdash; Attribute inheritance needs to apply to contracts, too
* [Bugzilla 10968](/bug/10968) &mdash; array element copy (1-N and N-N) ignores postblit attributes
* [Bugzilla 10969](/bug/10969) &mdash; Variadic template parameter re-use in function signature
* [Bugzilla 10970](/bug/10970) &mdash; Segfault in a simple test compiled without -g.
* [Bugzilla 10980](/bug/10980) &mdash; static initialization of immutable structs with disabled postblit fails
* [Bugzilla 10984](/bug/10984) &mdash; Frame access diagnostic should improve
* [Bugzilla 10989](/bug/10989) &mdash; [CTFE] Uncaught exception messages are not pretty printed if message wasn't literal
* [Bugzilla 10990](/bug/10990) &mdash; Passing in a module as a mixin to __traits(getUnitTests) behaves differently than passing in the module directly.
* [Bugzilla 10992](/bug/10992) &mdash; Trait getUnitTests skips first test if aggregate contains multiple tests.
* [Bugzilla 10993](/bug/10993) &mdash; mangling of voldemort types with lambdas changes during return type inference
* [Bugzilla 10995](/bug/10995) &mdash; CTFE failures for structs with void initialized members
* [Bugzilla 11002](/bug/11002) &mdash; Compiler doesn't see std.sys.linux.epoll.
* [Bugzilla 11075](/bug/11075) &mdash; ICE(struct.c) after gagged error in struct field initializer
* [Bugzilla 11125](/bug/11125) &mdash; UFCS instantiation of template causes template constraint to be skipped
* [Bugzilla 11132](/bug/11132) &mdash; Odd diagnostic with C-style struct initializer when union field is present
* [Bugzilla 11134](/bug/11134) &mdash; Inconsistent postblit call count depends on the pointer size
* [Bugzilla 11136](/bug/11136) &mdash; ICE on incorrect module declaration
* [Bugzilla 11137](/bug/11137) &mdash; Stack overflow on invalid output path
* [Bugzilla 11141](/bug/11141) &mdash; Missing .pdb file with phobos64
* [Bugzilla 11142](/bug/11142) &mdash; Wrong error message "no size yet for forward reference" for opaque struct
* [Bugzilla 11144](/bug/11144) &mdash; Better diagnostic for typeid symbol
* [Bugzilla 11145](/bug/11145) &mdash; Duplicated deprecation message "use of typedef is deprecated;"
* [Bugzilla 11146](/bug/11146) &mdash; Wrong line number of "identity assignment operator overload is illegal"
* [Bugzilla 11147](/bug/11147) &mdash; Nested structs in a union are not correctly initialized
* [Bugzilla 11151](/bug/11151) &mdash; Undetected overlapping initialization
* [Bugzilla 11159](/bug/11159) &mdash; [CTFE] Integer exponentiation give incorrect values
* [Bugzilla 11164](/bug/11164) &mdash; wrong dependencies generated when compiling with -main
* [Bugzilla 11182](/bug/11182) &mdash; dmd crashes on compiling regex
* [Bugzilla 11187](/bug/11187) &mdash; A small transitive const bug on struct copying

<h2 id="dmd-compiler-enhancements">DMD Compiler Enhancements</h2>

* [Bugzilla 658](/bug/658) &mdash; struct pointers in with()
* [Bugzilla 767](/bug/767) &mdash; compiler shall print dependencies and pragma(lib)
* [Bugzilla 5943](/bug/5943) &mdash; Power expression optimisation for 2^^unsigned
* [Bugzilla 8635](/bug/8635) &mdash; Allow postfix expressions for new
* [Bugzilla 9022](/bug/9022) &mdash; IFTI should support enclosing type/scope deduction
* [Bugzilla 9097](/bug/9097) &mdash; Value range propagation to disable some array bound tests
* [Bugzilla 9565](/bug/9565) &mdash; Index of static array should not print literal suffix
* [Bugzilla 10022](/bug/10022) &mdash; Importing packages
* [Bugzilla 10117](/bug/10117) &mdash; Support C++ class-scope static variables
* [Bugzilla 10236](/bug/10236) &mdash; Ddoc: Warning on wrong parameter names
* [Bugzilla 10334](/bug/10334) &mdash; ddoc should prefer simple syntax for template instantiations with one parameter
* [Bugzilla 10367](/bug/10367) &mdash; DDoc should output enum base type
* [Bugzilla 10688](/bug/10688) &mdash; Misleading error message when attempting a "private override"
* [Bugzilla 10724](/bug/10724) &mdash; Allow slice of string literal to convert to const(char)*
* [Bugzilla 10991](/bug/10991) &mdash; Implement trait to get vptr index of a method.
* [Bugzilla 11088](/bug/11088) &mdash; Diagnostics for enum member overflows should improve
* [Bugzilla 11257](/bug/11257) &mdash; Allow whole implicit conversion if one or more overlapped field could.

<h2 id="phobos-regressions">Phobos Regressions Fixed</h2>

* [Bugzilla 10218](/bug/10218) &mdash; std.typecons.opAssign is not CTFEable
* [Bugzilla 10268](/bug/10268) &mdash; [REG2.063] std.typecons.Nullable!JSONValue - error instantiating
* [Bugzilla 10355](/bug/10355) &mdash; fullyQualifiedName doesn't work with enums
* [Bugzilla 10468](/bug/10468) &mdash; Regression (2.063): Lockstep no longer works with iota
* [Bugzilla 10499](/bug/10499) &mdash; [REG 2.064] retro is no longer CTFE-able
* [Bugzilla 10686](/bug/10686) &mdash; No [] operator overload for immutable Tuple
* [Bugzilla 10866](/bug/10866) &mdash; Regression (2.064 git-head) Massive compiler slowdown
* [Bugzilla 10896](/bug/10896) &mdash; currently tools/ddemangle doesn't compile on git master
* [Bugzilla 10906](/bug/10906) &mdash; [2.064 git-head] Out of memory compiling Phobos on Windows
* [Bugzilla 10913](/bug/10913) &mdash; [2.064 git-head] regex/demange compilation failure
* [Bugzilla 11009](/bug/11009) &mdash; Regression (2.064 git-head): DMD consumes huge memory when it compiles enum containing many items
* [Bugzilla 11057](/bug/11057) &mdash; [REG2.064dev] New std.uni has icmp() partly broken
* [Bugzilla 11165](/bug/11165) &mdash; std.typecons._d_toObject conflicts with std.signals._d_toObject
* [Bugzilla 11283](/bug/11283) &mdash; [REG 2.064] assert in std/windows/syserror.d

<h2 id="phobos-bugs-fixed">Phobos Bugs Fixed</h2>

* [Bugzilla 2717](/bug/2717) &mdash; alloca(0) leaves stack unaligned on OSX
* [Bugzilla 4575](/bug/4575) &mdash; Uses of deprecated delete statement in D2 Phobos
* [Bugzilla 5224](/bug/5224) &mdash; std.algorithm.remove!(SwapStrategy.unstable) doesn't work
* [Bugzilla 5378](/bug/5378) &mdash; File.byLine terminator string
* [Bugzilla 5630](/bug/5630) &mdash; array() of iterable of immutable items
* [Bugzilla 5692](/bug/5692) &mdash; Printing complex numbers with negative imaginary part
* [Bugzilla 5942](/bug/5942) &mdash; Bitfields are overwritten erroneously
* [Bugzilla 6342](/bug/6342) &mdash; Tuple field access problem in pure function
* [Bugzilla 6407](/bug/6407) &mdash; take(map) problem
* [Bugzilla 6686](/bug/6686) &mdash; bitmanip bitfields are broken at 64 bits
* [Bugzilla 6893](/bug/6893) &mdash; Write of enum member represented with ubyte or ulong
* [Bugzilla 7756](/bug/7756) &mdash; iota(const doubles) problem
* [Bugzilla 8124](/bug/8124) &mdash; std.net.isemail not included in phobos.lib
* [Bugzilla 8330](/bug/8330) &mdash; std.algorithm.find doesn't handle reference type ranges correctly
* [Bugzilla 8474](/bug/8474) &mdash; bitfields doesn't work with 32 bit fields
* [Bugzilla 8806](/bug/8806) &mdash; fullyQualifiedName!T does not work for inner types
* [Bugzilla 9310](/bug/9310) &mdash; escapeShellCommand unittests are never run
* [Bugzilla 9384](/bug/9384) &mdash; std.socket: UnixAddress broken on Linux and others
* [Bugzilla 9548](/bug/9548) &mdash; BigInt: Wrong comparison result: BigInt("-1") > long.min
* [Bugzilla 9557](/bug/9557) &mdash; std.array.array of array of immutable structs
* [Bugzilla 9559](/bug/9559) &mdash; Range of Nullable doesn't work with std.array.array
* [Bugzilla 9579](/bug/9579) &mdash; std.regex.replace format argument should not require same constness as target string
* [Bugzilla 9599](/bug/9599) &mdash; File.byLine doesn't function properly with take
* [Bugzilla 9607](/bug/9607) &mdash; std.random.randomShuffle and partialShuffle don't work with Xorshift
* [Bugzilla 9629](/bug/9629) &mdash; toUpperInPlace doesn't work properly with unicode characters
* [Bugzilla 9725](/bug/9725) &mdash; std.string.format does wasteful UTF decoding
* [Bugzilla 9824](/bug/9824) &mdash; Emplace is broken
* [Bugzilla 9967](/bug/9967) &mdash; ParameterIdentifierTuple broken for setters
* [Bugzilla 10017](/bug/10017) &mdash; Can not assign to a Variant another Variant holding a bigger structure
* [Bugzilla 10078](/bug/10078) &mdash; std.string.indexOf(Char[], dchar, CaseSensitive) fails at compile time
* [Bugzilla 10130](/bug/10130) &mdash; map of iota with const step
* [Bugzilla 10161](/bug/10161) &mdash; std.datetime unittest failure "Libya Standard Time"
* [Bugzilla 10188](/bug/10188) &mdash; Wrong Document Comment on std.format.d(176)
* [Bugzilla 10216](/bug/10216) &mdash; Bad warning in std.process.kill
* [Bugzilla 10265](/bug/10265) &mdash; RandomSample fails when passed an InputRange as input
* [Bugzilla 10269](/bug/10269) &mdash; RandomSample should use popFrontExactly, not popFrontN, when skipping across input range
* [Bugzilla 10322](/bug/10322) &mdash; std.random.RandomSample.index() returns wrong value if called before front()
* [Bugzilla 10347](/bug/10347) &mdash; buildPath returns relative path when joining absolute with relative path
* [Bugzilla 10348](/bug/10348) &mdash; isRooted is either wrong or poorly specified
* [Bugzilla 10377](/bug/10377) &mdash; std.typecons.wrap doesn't consider private members
* [Bugzilla 10408](/bug/10408) &mdash; Two-function std.algorithm.reduce of a const array
* [Bugzilla 10426](/bug/10426) &mdash; Improve code coverage of std.random unittests
* [Bugzilla 10463](/bug/10463) &mdash; dirEntries() segfaults on paths the user does not have access to
* [Bugzilla 10469](/bug/10469) &mdash; WinAPI declarations in std.process should be moved to core.sys.windows.windows
* [Bugzilla 10474](/bug/10474) &mdash; When takeExactly returns a new range type, it fails to propagate all relevant attributes
* [Bugzilla 10510](/bug/10510) &mdash; enforce can't take an extern(C) function to call
* [Bugzilla 10517](/bug/10517) &mdash; readln(Char)(Char[] buf) accepts non-mutable buffers
* [Bugzilla 10536](/bug/10536) &mdash; std.typecons.wrap doesn't work with a class that defines opCast
* [Bugzilla 10543](/bug/10543) &mdash; std.algorithm.map incorrectly uses source range length for narrow strings
* [Bugzilla 10550](/bug/10550) &mdash; Xorshift32 and Xorshift160 do not generate uniformly-distributed random numbers
* [Bugzilla 10570](/bug/10570) &mdash; Example of `how` function for AutoImplement should work for non-abstract class
* [Bugzilla 10601](/bug/10601) &mdash; std.path.setExtension leaves trailing dot if extension is empty
* [Bugzilla 10607](/bug/10607) &mdash; DirEntry has no constructor
* [Bugzilla 10608](/bug/10608) &mdash; std.typecons.RefCounted has very poor diagnostics
* [Bugzilla 10644](/bug/10644) &mdash; Win64: wrong code when passing arguments through ...
* [Bugzilla 10647](/bug/10647) &mdash; AutoImplement should implement overridden member functions with 'override' attributes
* [Bugzilla 10660](/bug/10660) &mdash; ddoc on std.algorithm: Cheat sheet description for 'filter' is wrong
* [Bugzilla 10680](/bug/10680) &mdash; BigInt uses deprecated std.traits.unsigned
* [Bugzilla 10732](/bug/10732) &mdash; Example code for std.utf.toUTFindex does not work
* [Bugzilla 10773](/bug/10773) &mdash; std.algorithm.splitter produces infinite range with empty delimiter
* [Bugzilla 10796](/bug/10796) &mdash; std.regex: ctRegex bug with '.' and $ in multi-line mode
* [Bugzilla 10797](/bug/10797) &mdash; std.regex: ctRegex "codegen" bug with certain nested infinite loops
* [Bugzilla 10799](/bug/10799) &mdash; std.regex: ctRegex lookahead support
* [Bugzilla 10800](/bug/10800) &mdash; ParameterDefaultValueTuple returns an empty string for default values in property functions.
* [Bugzilla 10801](/bug/10801) &mdash; std.regex: support for lookbehind in ctRegex
* [Bugzilla 10802](/bug/10802) &mdash; std.regex: ctRegex fails to compile with backreference
* [Bugzilla 10874](/bug/10874) &mdash; std.conv.to should support conversion from ulong to int-based enum
* [Bugzilla 10893](/bug/10893) &mdash; Numerous DDoc parameter warnings in Phobos (as found by 10236)
* [Bugzilla 10898](/bug/10898) &mdash; LockingTextWriter segfaults in .init state
* [Bugzilla 10951](/bug/10951) &mdash; EnumMembers should document about returning duplicate members
* [Bugzilla 11068](/bug/11068) &mdash; raw formatting of chars and strings is wrong
* [Bugzilla 11089](/bug/11089) &mdash; std.string.toUpper doesn't work with 1:m mappings
* [Bugzilla 11152](/bug/11152) &mdash; formatChar doesn't handle `\0`
* [Bugzilla 11160](/bug/11160) &mdash; Bitfield compilation error with degenerate bitfields of length 32 & 64
* [Bugzilla 11194](/bug/11194) &mdash; std.container.Array.reserve calls opAssign on uninitialized data
* [Bugzilla 11222](/bug/11222) &mdash; std.string.isNumeric accepts a "+"
* [Bugzilla 11232](/bug/11232) &mdash; Windows sysErrorString only supports ASCII

<h2 id="phobos-enhancements">Phobos Enhancements</h2>

* [Bugzilla 4120](/bug/4120) &mdash; bigint implicit cast too bool
* [Bugzilla 4124](/bug/4124) &mdash; toString() for BitArray
* [Bugzilla 4850](/bug/4850) &mdash; std.conv.to isn't pure
* [Bugzilla 6154](/bug/6154) &mdash; std.math.abs on std.complex numbers too
* [Bugzilla 6381](/bug/6381) &mdash; math.floor, math.ceil are not pure functions.
* [Bugzilla 6626](/bug/6626) &mdash; std.complex.expi()
* [Bugzilla 9699](/bug/9699) &mdash; strip functions should have stripLeft/stripRight counterparts and be generic
* [Bugzilla 10092](/bug/10092) &mdash; Renaming std.range.chunks as std.range.chunked
* [Bugzilla 10314](/bug/10314) &mdash; Add std.traits.signed
* [Bugzilla 10538](/bug/10538) &mdash; std.typecons.wrap should consider opDispatch
* [Bugzilla 10621](/bug/10621) &mdash; dirEntry is (now) useless
* [Bugzilla 10717](/bug/10717) &mdash; std.ascii.toLower and toUpper should return char instead of dchar and avoid me to use a bad cast(char)
* [Bugzilla 10868](/bug/10868) &mdash; std.string.translate should take an optional buffer
* [Bugzilla 10881](/bug/10881) &mdash; Support %f formatting for a std.complex.complex
* [Bugzilla 10909](/bug/10909) &mdash; std.conv.to!(bool)(int): conversion from integer to bool
* [Bugzilla 11020](/bug/11020) &mdash; Add function for getting the current executable path
* [Bugzilla 11123](/bug/11123) &mdash; std.getopt should support functions

<h2 id="druntime-regressions">Druntime Regressions Fixed</h2>

* [Bugzilla 10976](/bug/10976) &mdash; thread_joinAll after main exit performed too late

<h2 id="druntime-bugs-fixed">Druntime Bugs Fixed</h2>

* [Bugzilla 6210](/bug/6210) &mdash; Associative array with array key often cannot be equated.
* [Bugzilla 6372](/bug/6372) &mdash; data loss due to possible bug in garbage collector
* [Bugzilla 7741](/bug/7741) &mdash; getHash inconsistent for const(char)[] vs. char[] and string
* [Bugzilla 8435](/bug/8435) &mdash; BigInts don't work well in associative arrays
* [Bugzilla 9783](/bug/9783) &mdash; profiling recursive function calls yields bad tree timing
* [Bugzilla 9852](/bug/9852) &mdash; Empty associative array crashes program
* [Bugzilla 10027](/bug/10027) &mdash; demangled name format of local function is wrong
* [Bugzilla 10118](/bug/10118) &mdash; BigInt as associative array key wrong behavior
* [Bugzilla 10323](/bug/10323) &mdash; getAMDcacheinfo needlessly allocates
* [Bugzilla 10420](/bug/10420) &mdash; Incorrect function attributes in `core.exception`
* [Bugzilla 10436](/bug/10436) &mdash; The runtime should print stack traces to stderr (like on *nix), not stdout
* [Bugzilla 10457](/bug/10457) &mdash; _d_toObject might fail with shared libraries
* [Bugzilla 10593](/bug/10593) &mdash; array's reserve/capacity go haywire if length has been changed prior
* [Bugzilla 10711](/bug/10711) &mdash; shared phobos library should not depend on _Dmain
* [Bugzilla 10720](/bug/10720) &mdash; ICE with is(aaOfNonCopyableStruct.nonExistingField)
* [Bugzilla 10894](/bug/10894) &mdash; Numerous DDoc parameter warnings in druntime (as found by 10236)

<h2 id="druntime-enhancements">Druntime Enhancements</h2>

* [Bugzilla 9190](/bug/9190) &mdash; Vector operations are not optimized for x86_64 architecture

<h2 id="installer-bugs-fixed">Installer Bugs Fixed</h2>

* [Bugzilla 10062](/bug/10062) &mdash; installers should use CDN

<h2 id="website-bugs-fixed">Website Bugs Fixed</h2>

* [Bugzilla 9533](/bug/9533) &mdash; CHM generation crashes
* [Bugzilla 10031](/bug/10031) &mdash; Link to old wiki on dlang.org
* [Bugzilla 10230](/bug/10230) &mdash; Duplicated buttons for runnable examples
* [Bugzilla 10410](/bug/10410) &mdash; Improve cast(void) documentation
* [Bugzilla 10461](/bug/10461) &mdash; Incorrect example of "depend on order of evaluation" expression
* [Bugzilla 10565](/bug/10565) &mdash; Level-5 titles are missing in Language reference
* [Bugzilla 10605](/bug/10605) &mdash; Lambda grammar is not sufficient
* [Bugzilla 10885](/bug/10885) &mdash; [std.range] refRange is missing from module description tables
* [Bugzilla 11001](/bug/11001) &mdash; Need documentation for __traits(getVirtualIndex)
* [Bugzilla 11036](/bug/11036) &mdash; Document that .stringof should not be used for code generation
